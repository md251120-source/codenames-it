<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Codenames â€” IT Support</title>

  <style>
    :root{
      --bg0:#070b16;
      --bg1:#0a1226;
      --panel:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.10);
      --text:#eaf0ff;
      --muted:#a7b4d6;

      --blue:#3b82f6;
      --red:#ef4444;
      --neutral:#cbd5e1;
      --black:#0b0f1a;

      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);

      /* Dark IT background */
      background:
        radial-gradient(900px 500px at 15% 0%, rgba(59,130,246,.18) 0%, transparent 60%),
        radial-gradient(900px 500px at 85% 0%, rgba(239,68,68,.14) 0%, transparent 60%),
        radial-gradient(900px 700px at 50% 110%, rgba(34,197,94,.10) 0%, transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* subtle tech grid + icons */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.04) 1px, transparent 1px);
      background-size: 54px 54px;
      mask-image: radial-gradient(circle at 50% 30%, rgba(0,0,0,.9), transparent 70%);
      opacity:.25;
    }
    body::after{
      content:"";
      position:fixed;
      inset:-20%;
      pointer-events:none;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), transparent 40%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,.06), transparent 45%),
        radial-gradient(circle at 50% 80%, rgba(255,255,255,.05), transparent 45%);
      filter: blur(22px);
      opacity:.65;
    }

    .app{ max-width:1200px; margin:0 auto; padding:18px; position:relative; z-index:1; }

    .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom:14px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      padding:14px 14px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .logo{
      width:52px; height:52px;
      border-radius:16px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      display:grid; place-items:center;
      font-size:26px;
      box-shadow: 0 14px 30px rgba(0,0,0,.25);
    }

    h1{ margin:0; font-size:26px; letter-spacing:.3px; }
    .sub{
      margin-top:4px;
      color:var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-weight:800;
      font-size:13px;
      opacity:.95;
    }
    .dot{ opacity:.55; }

    .right{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:flex-end;
    }

    .pills{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 999px;
      padding:10px 12px;
      font-weight:1000;
      font-size:13px;
      backdrop-filter: blur(8px);
      box-shadow: 0 14px 35px rgba(0,0,0,.25);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .pill b{ font-weight:1200; }
    .pill.blue b{ color: var(--blue); }
    .pill.red b{ color: var(--red); }
    .pill.neutral b{ color: var(--neutral); }
    .pill.time{ background: rgba(255,255,255,.08); }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .btn{
      border:none;
      border-radius: 14px;
      padding:10px 14px;
      font-weight:1100;
      cursor:pointer;
      color:var(--text);
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 14px 35px rgba(0,0,0,.25);
      backdrop-filter: blur(8px);
      transition: transform .12s ease, opacity .12s ease;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ background: rgba(34,197,94,.22); border-color: rgba(34,197,94,.25); }
    .btn.danger{ background: rgba(239,68,68,.18); border-color: rgba(239,68,68,.22); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    /* spymaster panel */
    #spymasterPanel{
      display:none;
      margin-top:12px;
      padding:14px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .smTitle{
      font-weight:1200;
      margin-bottom:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .smRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .smRow input, .smRow select{
      padding:11px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
      font-weight:1000;
    }
    .smRow input::placeholder{ color: rgba(234,240,255,.55); }
    #clueInput{ min-width:220px; flex:1; }
    #numInput{ width:120px; }
    #secondsInput{ width:170px; }

    .check{
      display:flex;
      gap:8px;
      align-items:center;
      font-weight:1000;
      color: var(--muted);
    }

    /* board */
    .board{
      margin-top:14px;
      display:grid;
      grid-template-columns: repeat(5, minmax(150px, 1fr));
      gap:14px;
    }

    .card{
      border:none;
      border-radius: 18px;
      padding:18px 14px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 14px 35px rgba(0,0,0,.25);
      color: var(--text);
      cursor:pointer;
      position:relative;
      overflow:hidden;
      transition: transform .10s ease, filter .15s ease, opacity .15s ease;
      backdrop-filter: blur(8px);
      text-align:center;
    }
    .card:hover{ transform: translateY(-2px); }
    .card:active{ transform: translateY(0px); }

    .word{
      font-weight:1200;
      letter-spacing:.3px;
      font-size:18px;
      text-shadow: 0 2px 10px rgba(0,0,0,.35);
    }

    .icon{
      position:absolute;
      top:10px;
      left:10px;
      width:22px;
      height:22px;
      opacity:.55;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.35));
    }

    /* hidden state for players */
    .hidden{
      background: rgba(255,255,255,.06);
    }

    /* spymaster hint border (unrevealed) */
    .spyHint.blue{ outline: 2px solid rgba(59,130,246,.55); }
    .spyHint.red{ outline: 2px solid rgba(239,68,68,.55); }
    .spyHint.neutral{ outline: 2px solid rgba(203,213,225,.45); }
    .spyHint.assassin{ outline: 2px solid rgba(0,0,0,.85); }

    /* revealed colors */
    .revealed.blue{ background: rgba(59,130,246,.85); border-color: rgba(59,130,246,.90); }
    .revealed.red{ background: rgba(239,68,68,.85); border-color: rgba(239,68,68,.90); }
    .revealed.neutral{ background: rgba(203,213,225,.88); border-color: rgba(203,213,225,.92); color:#0b1220; }
    .revealed.assassin{ background: rgba(0,0,0,.92); border-color: rgba(0,0,0,.92); }

    .revealed .icon{ opacity:.85; }

    /* overlay */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:18px;
    }
    .overlayBox{
      width:min(720px, 100%);
      border-radius: 24px;
      padding:32px 26px;
      text-align:center;
      box-shadow: 0 30px 90px rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
      animation: pop .25s ease;
    }
    @keyframes pop{ from{ transform:scale(.92); opacity:.2; } to{ transform:scale(1); opacity:1; } }

    .overlayTitle{
      font-size:44px;
      font-weight:1300;
      margin:0 0 10px;
    }
    .overlaySub{
      margin:0;
      color: rgba(255,255,255,.88);
      font-weight:900;
      font-size:16px;
    }

    .deny{
      max-width:640px;
      margin:60px auto;
      padding:18px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 20px;
      box-shadow: var(--shadow);
      text-align:center;
    }
    .deny h2{ margin:0 0 10px; font-weight:1300; }
    .deny p{ margin:0; color: var(--muted); font-weight:900; line-height:1.6; }

    @media (max-width: 860px){
      .board{ grid-template-columns: repeat(3, minmax(140px, 1fr)); }
    }
    @media (max-width: 520px){
      .board{ grid-template-columns: repeat(2, minmax(140px, 1fr)); }
      .overlayTitle{ font-size:34px; }
    }
  </style>
</head>

<body>
  <div class="app" id="appRoot" style="display:none;">
    <div class="top">
      <div class="brand">
        <div class="logo">ğŸ› ï¸</div>
        <div>
          <h1>Codenames â€” IT Support</h1>
          <div class="sub">
            <span id="roleLine">Role: â€”</span>
            <span class="dot">â€¢</span>
            <span id="turnLine">Turn: â€”</span>
            <span class="dot">â€¢</span>
            <span id="phaseLine">Phase: â€”</span>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="pills">
          <div class="pill blue">ğŸ”µ Blue left: <b id="blueLeft">â€”</b></div>
          <div class="pill red">ğŸ”´ Red left: <b id="redLeft">â€”</b></div>
          <div class="pill neutral">âšª Neutral: <b id="neutralLeft">â€”</b></div>
          <div class="pill time">â±ï¸ <b id="timerText">Timer OFF</b></div>
          <div class="pill">ğŸ¯ Guesses left: <b id="guessesLeft">0</b></div>
          <div class="pill">ğŸ’¡ Clue: <b id="clueShow">â€”</b></div>
          <div class="pill">ğŸ”¢ Num: <b id="numShow">â€”</b></div>
        </div>

        <div class="actions">
          <button class="btn primary" id="btnNewGame" style="display:none;">New Game</button>
        </div>
      </div>
    </div>

    <!-- Spymaster only -->
    <div id="spymasterPanel">
      <div class="smTitle" id="smTitle">ğŸ§  Spymaster Panel</div>

      <div class="smRow" style="margin-bottom:10px;">
        <label style="font-weight:1100;color:var(--muted);">Team</label>
        <select id="teamSelect">
          <option value="blue">BLUE</option>
          <option value="red">RED</option>
        </select>

        <input id="clueInput" placeholder="Clue (Ù…Ø«Ø§Ù„: NETWORK)" maxlength="20" />
        <input id="numInput" type="number" min="0" max="9" placeholder="Number" />
        <button class="btn" id="btnSendClue">Send Clue</button>
        <button class="btn danger" id="btnEndTurn">End Turn</button>
      </div>

      <div class="smRow">
        <label class="check">
          <input type="checkbox" id="useTimer" />
          Use Timer
        </label>
        <input id="secondsInput" type="number" min="10" max="600" placeholder="Seconds (Ù…Ø«Ø§Ù„: 60)" />
        <button class="btn" id="btnStartTimer">Start</button>
        <button class="btn" id="btnStopTimer">Stop</button>
      </div>

      <div style="margin-top:10px;color:var(--muted);font-weight:900;line-height:1.5;">
        âœ… Ø§Ù„Ø±Ù‚Ù… = Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø±Ø§ÙˆÙ†Ø¯. <br/>
        âœ… ÙƒÙ„Ù…Ø© Ø®Ø·Ø£/Ø¨ÙŠØ¶Ø§Ø¡/Ø­Ù‚ Ø§Ù„ÙØ±ÙŠÙ‚ Ø§Ù„Ø«Ø§Ù†ÙŠ = ÙŠÙ†ØªÙ‚Ù„ Ø§Ù„Ø¯ÙˆØ± ÙÙˆØ±Ù‹Ø§. <br/>
        âœ… Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡ = Ø®Ø³Ø§Ø±Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„ÙØ±ÙŠÙ‚ Ø§Ù„Ù„ÙŠ Ø¯ÙˆØ±Ù‡.
      </div>
    </div>

    <main class="board" id="board"></main>
  </div>

  <!-- Access denied -->
  <div class="deny" id="denyBox" style="display:none;">
    <h2>ğŸš« Access Denied</h2>
    <p>
      Ù„Ø§Ø²Ù… ØªÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±.<br/>
      Ø¥Ø°Ø§ Ø£Ù†Øª Ù…Ø¹ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©ØŒ Ø§Ø·Ù„Ø¨ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† Ø§Ù„Ù…Ù†Ø¸Ù‘Ù….
    </p>
  </div>

  <!-- Overlay -->
  <div class="overlay" id="overlay">
    <div class="overlayBox" id="overlayBox">
      <h2 class="overlayTitle" id="overlayTitle">â€”</h2>
      <p class="overlaySub" id="overlaySub">â€”</p>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

    // ====== ACCESS (Ø§Ù„Ø­Ù„ Ø§Ù„Ø£ÙˆÙ„) ======
    const REQUIRED_PW = "LY10";
    const qs = new URLSearchParams(location.search);
    const pw = qs.get("pw") || "";
    const isSpyLink = qs.get("spy") === "1";

    const appRoot = document.getElementById("appRoot");
    const denyBox = document.getElementById("denyBox");
    if(pw !== REQUIRED_PW){
      denyBox.style.display = "block";
      appRoot.style.display = "none";
      throw new Error("Access denied");
    }else{
      appRoot.style.display = "block";
      denyBox.style.display = "none";
    }

    // ====== Firebase Config (ÙƒÙ…Ø§ Ø¹Ù†Ø¯Ùƒ) ======
    const firebaseConfig = {
      apiKey: "AIzaSyBaQKAER5HLq6LhPWIaIqrBRpd4qn0lUss",
      authDomain: "codenames-it-support.firebaseapp.com",
      projectId: "codenames-it-support",
      storageBucket: "codenames-it-support.firebasestorage.app",
      messagingSenderId: "328187580670",
      appId: "1:328187580670:web:b18953ccf1ad374a1dd5af",
      measurementId: "G-NVG0G4SM6D"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ====== ØºØ±ÙØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· ======
    const ROOM_ID = "CLASS1";
    const roomRef = doc(db, "rooms", ROOM_ID);

    // ====== ÙƒÙ„Ù…Ø§Øª IT Support (25) ======
    const WORDS = [
      "Ticket","Service Desk","VPN","Firewall","DNS",
      "DHCP","IP Address","Router","Switch","Wi-Fi",
      "Active Directory","Password","MFA","Account","Permissions",
      "Hardware","Software","Printer","Antivirus","Patch",
      "Backup","Restore","Incident","Outage","Email"
    ];

    // ====== Helpers ======
    const otherTeam = (t) => t === "blue" ? "red" : "blue";
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    // icons (simple inline SVG)
    const ICONS = [
      // server
      `<svg viewBox="0 0 24 24" fill="none"><path d="M4 6c0-1.1.9-2 2-2h12c1.1 0 2 .9 2 2v3c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V6Z" stroke="currentColor" stroke-width="2"/><path d="M4 13c0-1.1.9-2 2-2h12c1.1 0 2 .9 2 2v3c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2v-3Z" stroke="currentColor" stroke-width="2"/><circle cx="8" cy="8" r="1" fill="currentColor"/><circle cx="8" cy="15" r="1" fill="currentColor"/></svg>`,
      // gear
      `<svg viewBox="0 0 24 24" fill="none"><path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z" stroke="currentColor" stroke-width="2"/><path d="M19 12a7.6 7.6 0 0 0-.1-1l2-1.5-2-3.5-2.4 1a8 8 0 0 0-1.7-1l-.4-2.6H10l-.4 2.6a8 8 0 0 0-1.7 1l-2.4-1-2 3.5 2 1.5A7.6 7.6 0 0 0 5 12c0 .34.03.67.1 1l-2 1.5 2 3.5 2.4-1a8 8 0 0 0 1.7 1l.4 2.6h4.2l.4-2.6a8 8 0 0 0 1.7-1l2.4 1 2-3.5-2-1.5c.07-.33.1-.66.1-1Z" stroke="currentColor" stroke-width="2" opacity=".9"/></svg>`,
      // shield
      `<svg viewBox="0 0 24 24" fill="none"><path d="M12 3 20 6v6c0 5-3.4 9.4-8 10-4.6-.6-8-5-8-10V6l8-3Z" stroke="currentColor" stroke-width="2"/></svg>`,
      // network
      `<svg viewBox="0 0 24 24" fill="none"><circle cx="6" cy="12" r="2" stroke="currentColor" stroke-width="2"/><circle cx="18" cy="6" r="2" stroke="currentColor" stroke-width="2"/><circle cx="18" cy="18" r="2" stroke="currentColor" stroke-width="2"/><path d="M7.7 11.1 16.2 6.9M7.7 12.9l8.5 4.2" stroke="currentColor" stroke-width="2"/></svg>`
    ];

    function playWinSound(){
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.connect(g);
        g.connect(ctx.destination);
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
        const notes = [523.25, 659.25, 783.99, 1046.5];
        notes.forEach((f, i) => o.frequency.setValueAtTime(f, now + i * 0.12));
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.55);
        o.start(now);
        o.stop(now + 0.60);
      } catch {}
    }

    // ====== Create state ======
    function createNewGame(){
      const startingTeam = Math.random() < 0.5 ? "blue" : "red";
      const blueCount = startingTeam === "blue" ? 9 : 8;
      const redCount  = startingTeam === "red" ? 9 : 8;
      const assassinCount = 1;
      const neutralCount = 25 - blueCount - redCount - assassinCount;

      const colors = shuffle([
        ...Array(blueCount).fill("blue"),
        ...Array(redCount).fill("red"),
        ...Array(neutralCount).fill("neutral"),
        ...Array(assassinCount).fill("assassin")
      ]);

      const words = shuffle(WORDS);

      const mapping = {};
      for(let i=0;i<25;i++){
        mapping[words[i]] = {
          team: colors[i],
          revealed: false,
          icon: Math.floor(Math.random()*ICONS.length) // store icon index
        };
      }

      return {
        roomId: ROOM_ID,
        words,
        mapping,
        startingTeam,
        activeTeam: startingTeam,
        phase: "clue",          // clue | guess
        clueText: "â€”",
        clueNumber: "â€”",
        guessesLeft: 0,

        // timer
        timerEnabled: false,
        timerSeconds: 60,
        timerRunning: false,
        timerEndsAt: null,

        // end
        winner: null,           // "blue" | "red"
        loser: null,            // "blue" | "red" (for assassin)
        endedBy: null,          // "win" | "assassin"
        updatedAt: serverTimestamp()
      };
    }

    async function ensureRoom(){
      const snap = await getDoc(roomRef);
      if(!snap.exists()){
        await setDoc(roomRef, createNewGame());
      }
    }

    function countLeft(mapping){
      let blue=0, red=0, neutral=0;
      for(const w in mapping){
        const c = mapping[w];
        if(!c.revealed && c.team==="blue") blue++;
        if(!c.revealed && c.team==="red") red++;
        if(!c.revealed && c.team==="neutral") neutral++;
      }
      return {blue, red, neutral};
    }

    // ====== UI refs ======
    const roleLine = document.getElementById("roleLine");
    const turnLine = document.getElementById("turnLine");
    const phaseLine = document.getElementById("phaseLine");

    const blueLeftEl = document.getElementById("blueLeft");
    const redLeftEl = document.getElementById("redLeft");
    const neutralLeftEl = document.getElementById("neutralLeft");

    const timerText = document.getElementById("timerText");
    const guessesLeftEl = document.getElementById("guessesLeft");
    const clueShow = document.getElementById("clueShow");
    const numShow = document.getElementById("numShow");

    const spymasterPanel = document.getElementById("spymasterPanel");
    const btnNewGame = document.getElementById("btnNewGame");

    const teamSelect = document.getElementById("teamSelect");
    const clueInput = document.getElementById("clueInput");
    const numInput = document.getElementById("numInput");
    const btnSendClue = document.getElementById("btnSendClue");
    const btnEndTurn = document.getElementById("btnEndTurn");

    const useTimer = document.getElementById("useTimer");
    const secondsInput = document.getElementById("secondsInput");
    const btnStartTimer = document.getElementById("btnStartTimer");
    const btnStopTimer = document.getElementById("btnStopTimer");

    const board = document.getElementById("board");

    const overlay = document.getElementById("overlay");
    const overlayBox = document.getElementById("overlayBox");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlaySub = document.getElementById("overlaySub");

    // ====== Role ======
    // projector: spy=0
    // spymaster: spy=1 (and choose team inside)
    let myRole = isSpyLink ? "spymaster" : "player";
    roleLine.textContent = "Role: " + (myRole === "spymaster" ? "Spymaster" : "Player/Projector");

    if(myRole === "spymaster"){
      spymasterPanel.style.display = "block";
      btnNewGame.style.display = "inline-block";
    }else{
      spymasterPanel.style.display = "none";
      btnNewGame.style.display = "none";
    }

    // store team choice locally on spymaster device
    if(myRole === "spymaster"){
      const savedTeam = localStorage.getItem("cn_team");
      if(savedTeam === "blue" || savedTeam === "red") teamSelect.value = savedTeam;
      teamSelect.addEventListener("change", ()=> localStorage.setItem("cn_team", teamSelect.value));
    }

    // ====== Game actions ======
    async function endTurn(cur){
      const next = otherTeam(cur.activeTeam);
      await updateDoc(roomRef, {
        activeTeam: next,
        phase: "clue",
        clueText: "â€”",
        clueNumber: "â€”",
        guessesLeft: 0,
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    }

    async function setWinner(team){
      await updateDoc(roomRef, {
        winner: team,
        endedBy: "win",
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    }

    async function assassinHit(cur){
      const loser = cur.activeTeam;
      const winner = otherTeam(cur.activeTeam);
      await updateDoc(roomRef, {
        winner,
        loser,
        endedBy: "assassin",
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    }

    async function reveal(word){
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner) return;

      const mapping = cur.mapping || {};
      const card = mapping[word];
      if(!card || card.revealed) return;

      // reveal
      card.revealed = true;

      // assassin
      if(card.team === "assassin"){
        await updateDoc(roomRef, { mapping, updatedAt: serverTimestamp() });
        await assassinHit(cur);
        return;
      }

      // check win after revealing (only if all of a team done)
      const left = countLeft(mapping);
      await updateDoc(roomRef, { mapping, updatedAt: serverTimestamp() });
      if(left.blue === 0){ await setWinner("blue"); return; }
      if(left.red === 0){ await setWinner("red"); return; }

      // if in guessing phase: apply your rules
      if(cur.phase === "guess"){
        const active = cur.activeTeam;

        if(card.team === active){
          // correct -> reduce guesses
          const newGuesses = Math.max(0, (cur.guessesLeft || 0) - 1);
          await updateDoc(roomRef, { guessesLeft: newGuesses, updatedAt: serverTimestamp() });

          // if finished allowed guesses -> auto end turn
          if(newGuesses <= 0){
            const snap2 = await getDoc(roomRef);
            if(snap2.exists() && !snap2.data().winner){
              await endTurn(snap2.data());
            }
          }
        }else{
          // wrong team OR neutral -> end turn immediately
          const snap2 = await getDoc(roomRef);
          if(snap2.exists() && !snap2.data().winner){
            await endTurn(snap2.data());
          }
        }
      }
    }

    // ====== Timer ======
    let timerInterval = null;
    function updateTimerUI(state){
      if(!state.timerEnabled){
        timerText.textContent = "Timer OFF";
        return;
      }
      if(!state.timerRunning || !state.timerEndsAt){
        timerText.textContent = "Timer READY";
        return;
      }
      const ms = state.timerEndsAt - Date.now();
      const s = Math.max(0, Math.ceil(ms/1000));
      timerText.textContent = "Time: " + s + "s";

      // when time ends => end turn automatically (only once)
      if(s <= 0){
        // stop local ticking
        if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
        getDoc(roomRef).then(sn=>{
          if(!sn.exists()) return;
          const cur = sn.data();
          if(cur.timerRunning && cur.phase === "guess" && !cur.winner){
            endTurn(cur);
          }
        });
      }
    }

    // ====== Overlay ======
    function showOverlay(type, state){
      overlay.style.display = "flex";

      if(type === "win"){
        overlay.style.background = "rgba(16,185,129,.92)";
        overlayTitle.textContent = (state.winner === "blue" ? "BLUE TEAM WINS âœ…" : "RED TEAM WINS âœ…");
        overlaySub.textContent = "ØªÙ… Ø¬Ù…Ø¹ ÙƒÙ„ ÙƒÙ„Ù…Ø§Øª Ø§Ù„ÙØ±ÙŠÙ‚ ğŸ‰";
        playWinSound();
      }else if(type === "assassin"){
        overlay.style.background = "rgba(0,0,0,.92)";
        overlayTitle.textContent = (state.loser === "blue" ? "BLUE TEAM LOST â˜ ï¸" : "RED TEAM LOST â˜ ï¸");
        overlaySub.textContent = "ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡";
      }
    }

    function hideOverlay(){
      overlay.style.display = "none";
    }

    // ====== Render ======
    let latest = null;

    function render(state){
      latest = state;

      turnLine.textContent = "Turn: " + (state.activeTeam || "â€”").toUpperCase();
      phaseLine.textContent = "Phase: " + (state.phase || "â€”").toUpperCase();

      guessesLeftEl.textContent = String(state.guessesLeft || 0);
      clueShow.textContent = state.clueText || "â€”";
      numShow.textContent = state.clueNumber || "â€”";

      const left = countLeft(state.mapping || {});
      blueLeftEl.textContent = left.blue;
      redLeftEl.textContent = left.red;
      neutralLeftEl.textContent = left.neutral;

      // spymaster buttons enabling
      if(myRole === "spymaster"){
        const myTeam = teamSelect.value;
        const myTurn = myTeam === state.activeTeam;

        btnSendClue.disabled = !(myTurn && state.phase === "clue" && !state.winner);
        btnEndTurn.disabled  = !(myTurn && state.phase === "guess" && !state.winner);

        useTimer.checked = !!state.timerEnabled;
        secondsInput.value = state.timerSeconds ?? 60;

        btnStartTimer.disabled = !(myTurn && state.phase === "guess" && state.timerEnabled && !state.timerRunning && !state.winner);
        btnStopTimer.disabled  = !(myTurn && state.timerRunning && !state.winner);
      }

      // timer
      if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
      updateTimerUI(state);
      timerInterval = setInterval(()=> updateTimerUI(latest), 250);

      // overlay only on game end
      if(state.winner){
        if(state.endedBy === "assassin") showOverlay("assassin", state);
        else showOverlay("win", state);
      }else{
        hideOverlay();
      }

      // draw board
      board.innerHTML = "";
      const order = state.words || Object.keys(state.mapping || {});
      for(const w of order){
        const info = state.mapping?.[w];
        if(!info) continue;

        const btn = document.createElement("button");
        btn.className = "card";
        btn.type = "button";

        // icon
        const icon = document.createElement("div");
        icon.className = "icon";
        icon.innerHTML = ICONS[info.icon ?? 0];
        btn.appendChild(icon);

        // word
        const word = document.createElement("div");
        word.className = "word";
        word.textContent = w;
        btn.appendChild(word);

        // classes:
        if(myRole === "spymaster"){
          // show hints even unrevealed
          if(!info.revealed){
            btn.classList.add("spyHint");
            btn.classList.add(info.team);
          }
        }else{
          // player sees nothing until revealed
          if(!info.revealed) btn.classList.add("hidden");
        }

        if(info.revealed){
          btn.classList.add("revealed");
          btn.classList.add(info.team);
        }

        btn.addEventListener("click", async ()=>{
          if(latest?.winner) return;
          await reveal(w);
        });

        board.appendChild(btn);
      }
    }

    // ====== Spymaster actions ======
    btnNewGame.addEventListener("click", async ()=>{
      if(myRole !== "spymaster") return;
      const ok = confirm("Ø£ÙƒÙŠØ¯ ØªØ¨ÙŠÙ† ØªØ¨Ø¯Ø£ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©ØŸ");
      if(!ok) return;
      await setDoc(roomRef, createNewGame());
    });

    btnSendClue.addEventListener("click", async ()=>{
      if(myRole !== "spymaster") return;
      if(!latest || latest.winner) return;

      const myTeam = teamSelect.value;
      if(myTeam !== latest.activeTeam) return;
      if(latest.phase !== "clue") return;

      const clue = (clueInput.value || "").trim().toUpperCase();
      const n = Number(numInput.value);

      if(!clue || !Number.isFinite(n) || n < 0 || n > 9){
        alert("Ø§ÙƒØªØ¨ Clue + Ø±Ù‚Ù… Ù…Ù† 0 Ø¥Ù„Ù‰ 9");
        return;
      }

      await updateDoc(roomRef, {
        clueText: clue,
        clueNumber: String(n),
        guessesLeft: n,
        phase: "guess",
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });

      clueInput.value = "";
      numInput.value = "";
    });

    btnEndTurn.addEventListener("click", async ()=>{
      if(myRole !== "spymaster") return;
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner) return;

      const myTeam = teamSelect.value;
      if(myTeam !== cur.activeTeam) return;
      if(cur.phase !== "guess") return;

      await endTurn(cur);
    });

    useTimer.addEventListener("change", async ()=>{
      if(myRole !== "spymaster") return;
      const enabled = !!useTimer.checked;
      const seconds = clamp(Number(secondsInput.value || 60), 10, 600);
      await updateDoc(roomRef, {
        timerEnabled: enabled,
        timerSeconds: Number.isFinite(seconds) ? seconds : 60,
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    });

    secondsInput.addEventListener("change", async ()=>{
      if(myRole !== "spymaster") return;
      const seconds = clamp(Number(secondsInput.value || 60), 10, 600);
      await updateDoc(roomRef, {
        timerSeconds: Number.isFinite(seconds) ? seconds : 60,
        updatedAt: serverTimestamp()
      });
    });

    btnStartTimer.addEventListener("click", async ()=>{
      if(myRole !== "spymaster") return;
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner) return;

      const myTeam = teamSelect.value;
      if(myTeam !== cur.activeTeam) return;
      if(cur.phase !== "guess") return;
      if(!cur.timerEnabled) return;

      const secs = clamp(Number(cur.timerSeconds || 60), 10, 600);
      const ends = Date.now() + secs * 1000;

      await updateDoc(roomRef, {
        timerRunning: true,
        timerEndsAt: ends,
        updatedAt: serverTimestamp()
      });
    });

    btnStopTimer.addEventListener("click", async ()=>{
      if(myRole !== "spymaster") return;
      await updateDoc(roomRef, {
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    });

    // ====== Start ======
    await ensureRoom();
    onSnapshot(roomRef, (snap)=>{
      if(!snap.exists()) return;
      render(snap.data());
    });
  </script>
</body>
</html>
