<!-- index.html  |  IT SUPPORT ACADEMY ‚Äî CODE MISSION
     ‚úÖ Responsive (mobile/tablet/laptop)
     ‚úÖ Realtime sync via Firebase Firestore (same result everywhere)
     ‚úÖ Fast UI (CSS transitions only, lightweight icons, no heavy images)
     ‚úÖ Simple English (A1/B1)

     HOW TO USE:
     1) Create a Firebase project + enable Firestore.
     2) Paste your Firebase config in FIREBASE_CONFIG below.
     3) Host this file (or use local server).
     4) Open as:
        - Board (players/projector): index.html?room=CLASS1
        - Spymaster (or use in-app button): index.html?room=CLASS1&role=spymaster&team=blue
        - Spymaster red: index.html?room=CLASS1&role=spymaster&team=red
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IT Support Academy ‚Äî Code Mission</title>
  <style>
    :root{
      --bg0:#0f1c2e;
      --bg1:#12243a;
      --card:#eef4ff;
      --card2:#dfe9ff;
      --text:#0b1220;
      --muted:rgba(255,255,255,.72);
      --muted2:rgba(255,255,255,.55);
      --blue:#2f6bff;
      --red:#ff3b4f;
      --neu:#c7d0e0;
      --ass:#0a0a0a;
      --good:#2bd17e;

      --shadow:0 10px 30px rgba(0,0,0,.25);
      --radius:16px;
      --radius2:12px;
      --border:1px solid rgba(255,255,255,.14);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(47,107,255,.18), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(255,59,79,.12), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      color:white;
      min-height:100vh;
      overflow-x:hidden;
    }

    /* subtle moving grid background (very light) */
    .gridBG{
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.12;
      background:
        linear-gradient(to right, rgba(255,255,255,.25) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.25) 1px, transparent 1px);
      background-size: 44px 44px;
      mix-blend-mode: overlay;
      transform: translateZ(0);
      animation: gridMove 20s linear infinite;
    }
    @keyframes gridMove{
      from{ background-position:0 0, 0 0; }
      to{ background-position:120px 0, 0 120px; }
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:14px 16px;
      position:sticky; top:0;
      background: rgba(10,16,28,.62);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.10);
      z-index:50;
    }

    .brand{
      display:flex; flex-direction:column; line-height:1.1;
    }
    .brand b{font-size:14px; letter-spacing:.6px}
    .brand span{font-size:12px; color:var(--muted2); font-weight:700}

    .topRight{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }

    .pillRow{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
    }

    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      border: var(--border);
      background: rgba(255,255,255,.08);
      font-size:12px;
      font-weight:900;
      letter-spacing:.2px;
      user-select:none;
      white-space:nowrap;
    }
    .pill strong{font-size:14px}

    .pill.blue{ box-shadow: 0 0 0 rgba(47,107,255,0); }
    .pill.red { box-shadow: 0 0 0 rgba(255,59,79,0); }

    .pill.active.blue{
      border-color: rgba(47,107,255,.7);
      background: rgba(47,107,255,.12);
      box-shadow: 0 0 18px rgba(47,107,255,.28);
      animation: pulse 2.6s ease-in-out infinite;
    }
    .pill.active.red{
      border-color: rgba(255,59,79,.7);
      background: rgba(255,59,79,.12);
      box-shadow: 0 0 18px rgba(255,59,79,.24);
      animation: pulse 2.6s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform:translateY(0); }
      50%{ transform:translateY(-1px); }
    }

    .btn{
      border: var(--border);
      background: rgba(255,255,255,.10);
      color:white;
      font-weight:900;
      letter-spacing:.2px;
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .12s ease, background .18s ease;
      user-select:none;
      display:inline-flex; align-items:center; gap:8px;
      font-size:12.5px;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.14); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ background: rgba(47,107,255,.18); border-color: rgba(47,107,255,.6); }
    .btn.danger{ background: rgba(255,59,79,.16); border-color: rgba(255,59,79,.55); }
    .btn.good{ background: rgba(43,209,126,.16); border-color: rgba(43,209,126,.55); }
    .btn.ghost{ background: transparent; }

    .btn:disabled{
      opacity:.55; cursor:not-allowed; transform:none;
    }

    .main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 14px 28px;
    }

    .hud{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-bottom: 10px;
    }

    .missionCard{
      border: var(--border);
      background: rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 12px 12px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }

    .clueBox{
      display:flex; align-items:flex-end; gap:12px; flex-wrap:wrap;
    }
    .tag{
      font-size:11px; color:var(--muted2);
      font-weight:900; letter-spacing:.8px;
    }
    .clueText{
      font-size:20px; font-weight:1000; letter-spacing:.6px;
    }
    .numBadge{
      width:40px; height:40px;
      border-radius: 14px;
      display:grid; place-items:center;
      background: rgba(255,255,255,.12);
      border: var(--border);
      font-weight:1000;
      font-size:18px;
    }
    .subRow{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      color: var(--muted);
      font-weight:900;
      font-size:12px;
    }
    .mini{
      border: var(--border);
      background: rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 999px;
      display:flex; gap:8px; align-items:center;
    }

    .timerCircle{
      width:28px; height:28px;
      border-radius: 999px;
      border: 3px solid rgba(255,255,255,.45);
      position:relative;
      overflow:hidden;
      background: rgba(255,255,255,.06);
    }
    .timerFill{
      position:absolute; inset:0;
      transform-origin: bottom;
      transform: scaleY(1);
      background: rgba(47,107,255,.28);
      transition: transform .2s linear;
    }

    .board{
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:10px;
      margin-top: 10px;
    }

    .card{
      background: linear-gradient(180deg, var(--card), var(--card2));
      color: var(--text);
      border-radius: var(--radius2);
      padding: 12px 10px;
      min-height: 62px;
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 18px rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      cursor:pointer;
      user-select:none;
      position:relative;
      overflow:hidden;
      transform: translateZ(0);
      transition: transform .12s ease, filter .18s ease;
    }
    .card:hover{ transform: translateY(-2px); filter: brightness(1.02); }
    .card.locked{ cursor: not-allowed; filter: saturate(.9); }
    .word{
      font-weight:1000;
      letter-spacing:.4px;
      font-size: clamp(12px, 1.9vw, 16px);
      line-height:1.1;
      text-transform: uppercase;
    }
    .icon{
      width:26px; height:26px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,.08);
      display:grid; place-items:center;
      background: rgba(255,255,255,.6);
      font-size:16px;
      flex: 0 0 auto;
    }

    /* revealed states (for everyone) */
    .card.revealed{ cursor: default; transform:none; }
    .card.revealed .icon{ background: rgba(255,255,255,.22); border-color: rgba(255,255,255,.25); }
    .card.revealed .word{ color: white; text-shadow: 0 1px 0 rgba(0,0,0,.25); }

    .card.revealed.blue{ background: linear-gradient(180deg, rgba(47,107,255,.92), rgba(47,107,255,.74)); border-color: rgba(255,255,255,.20); }
    .card.revealed.red { background: linear-gradient(180deg, rgba(255,59,79,.92), rgba(255,59,79,.74)); border-color: rgba(255,255,255,.20); }
    .card.revealed.neu { background: linear-gradient(180deg, rgba(199,208,224,.92), rgba(199,208,224,.74)); }
    .card.revealed.ass { background: linear-gradient(180deg, rgba(20,20,20,.95), rgba(0,0,0,.86)); }

    /* spymaster "map" color tint before reveal */
    .spyTint{
      position:absolute; inset:0;
      opacity:.18;
      pointer-events:none;
    }
    .spyTint.blue{ background: rgba(47,107,255,.9); }
    .spyTint.red { background: rgba(255,59,79,.9); }
    .spyTint.neu { background: rgba(180,190,205,.9); }
    .spyTint.ass { background: rgba(0,0,0,.9); }

    /* overlays */
    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index:200;
      background: rgba(5,8,14,.72);
      backdrop-filter: blur(10px);
    }
    .overlay.show{ display:flex; }
    .modal{
      width:min(520px, 100%);
      background: rgba(255,255,255,.10);
      border: var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .modal h2{
      margin:0 0 6px;
      font-size:16px;
      letter-spacing:.6px;
    }
    .modal p{
      margin:0 0 12px;
      color: var(--muted);
      font-weight:800;
      font-size:12.5px;
      line-height:1.35;
    }
    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center;
    }
    .field{
      flex: 1 1 180px;
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: var(--border);
      background: rgba(255,255,255,.08);
    }
    .field input{
      width:100%;
      border:none;
      outline:none;
      background: transparent;
      color: white;
      font-weight:900;
      letter-spacing:.4px;
      font-size:13px;
    }
    .hint{
      font-size:11px; color: var(--muted2); font-weight:900;
      margin-top:10px;
    }

    /* spymaster panel */
    .spyPanel{
      margin-top: 10px;
      border: var(--border);
      background: rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: var(--shadow);
      display:none;
    }
    .spyHead{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:10px;
    }
    .teamPill{
      padding: 8px 10px;
      border-radius: 999px;
      font-weight:1000;
      font-size:12px;
      letter-spacing:.3px;
      border: var(--border);
      background: rgba(255,255,255,.08);
    }
    .teamPill.blue{ border-color: rgba(47,107,255,.65); background: rgba(47,107,255,.12); }
    .teamPill.red { border-color: rgba(255,59,79,.65); background: rgba(255,59,79,.12); }

    .spyControls{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }

    .lockScreen{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:150;
      background: rgba(5,8,14,.72);
      backdrop-filter: blur(10px);
      padding:18px;
    }
    .lockScreen.show{ display:flex; }

    /* end screen */
    .endFull{
      position:fixed; inset:0;
      display:none;
      z-index:250;
      align-items:center;
      justify-content:center;
      padding:18px;
      color:white;
    }
    .endFull.show{ display:flex; }
    .endCard{
      width:min(620px,100%);
      border-radius: 20px;
      padding: 18px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      text-align:center;
    }
    .endCard h1{ margin:0 0 6px; font-size:26px; letter-spacing:.8px; }
    .endCard p{ margin:0 0 14px; color: var(--muted); font-weight:900; }
    .endBtns{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }

    .endFull.blueWin{ background: radial-gradient(900px 600px at 40% 10%, rgba(47,107,255,.35), transparent 60%), linear-gradient(180deg, rgba(22,48,95,.95), rgba(8,14,25,.98)); }
    .endFull.redWin { background: radial-gradient(900px 600px at 40% 10%, rgba(255,59,79,.30), transparent 60%), linear-gradient(180deg, rgba(90,22,28,.95), rgba(8,14,25,.98)); }
    .endFull.loss   { background: radial-gradient(900px 600px at 40% 10%, rgba(0,0,0,.45), transparent 60%), linear-gradient(180deg, rgba(10,10,10,.98), rgba(2,4,10,.98)); }

    /* small banners */
    .toast{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: 18px;
      padding: 10px 12px;
      border-radius: 999px;
      border: var(--border);
      background: rgba(255,255,255,.10);
      color:white;
      font-weight:1000;
      font-size:12.5px;
      display:none;
      z-index:300;
      box-shadow: var(--shadow);
    }
    .toast.show{ display:block; animation: pop .22s ease; }
    @keyframes pop{ from{ transform:translateX(-50%) translateY(8px); opacity:.2 } to{ transform:translateX(-50%) translateY(0); opacity:1 } }

    .banner{
      display:none;
      margin-top: 8px;
      color: rgba(255,255,255,.90);
      font-weight:1000;
      font-size:12px;
    }
    .banner.show{ display:block; }

    /* mobile tweaks */
    @media (max-width: 760px){
      header{ padding:12px 12px; }
      .board{ gap:8px; }
      .card{ min-height: 56px; padding:10px 10px; }
      .icon{ width:24px; height:24px; border-radius: 9px; font-size:15px; }
      .numBadge{ width:38px; height:38px; }
    }
  </style>
</head>
<body>
  <div class="gridBG"></div>

  <header>
    <div class="brand">
      <b>IT SUPPORT ACADEMY</b>
      <span id="roomLabel">ROOM: ‚Äî</span>
    </div>

    <div class="topRight">
      <div class="pillRow">
        <div class="pill blue" id="bluePill">üîµ <span>Blue</span> <strong id="blueLeft">‚Äî</strong></div>
        <div class="pill red"  id="redPill">üî¥ <span>Red</span> <strong id="redLeft">‚Äî</strong></div>
        <div class="pill" id="timerPill">‚è±Ô∏è <span id="timerText">Timer OFF</span></div>
      </div>

      <button class="btn" id="btnFullscreen">‚õ∂ Full Screen</button>
      <button class="btn" id="btnSilent">üîä Sound ON</button>
      <button class="btn primary" id="btnMain">üè† Main</button>
    </div>
  </header>

  <div class="main">

    <div class="hud">
      <div class="missionCard">
        <div class="clueBox">
          <div>
            <div class="tag">MISSION CODE</div>
            <div class="clueText" id="clueText">‚Äî</div>
          </div>
          <div class="numBadge" id="clueNum">‚Äî</div>
        </div>

        <div class="subRow">
          <div class="mini">üéØ Guesses Left: <b id="guessesLeft">‚Äî</b></div>
          <div class="mini" title="Thinking Mode"><span id="thinkingIcon">üß†</span> <span id="thinkingText">‚Äî</span></div>
          <div class="mini" title="Timer">
            <div class="timerCircle"><div class="timerFill" id="timerFill"></div></div>
            <b id="timerCountdown">‚Äî</b>
          </div>
        </div>
      </div>

      <div class="banner" id="momentumBanner">üî• Momentum</div>
      <div class="banner" id="finalBanner">‚ö° Final Target Remaining</div>

      <div class="spyPanel" id="spyPanel">
        <div class="spyHead">
          <div style="display:flex;flex-direction:column;gap:3px;">
            <div class="tag">SPYMASTER PANEL</div>
            <div style="font-weight:1000;letter-spacing:.4px;">Send a clue (one word) + number</div>
          </div>
          <div class="teamPill" id="spyTeamPill">TEAM</div>
        </div>

        <div class="spyControls">
          <div class="field" style="flex:2 1 220px;">
            <span style="opacity:.9;">‚úèÔ∏è</span>
            <input id="clueInput" maxlength="20" placeholder="CLUE (ONE WORD)" />
          </div>

          <div class="field" style="width:140px; flex:0 0 140px;">
            <span style="opacity:.9;">üî¢</span>
            <input id="numInput" type="number" min="0" max="9" placeholder="NUMBER" />
          </div>

          <button class="btn primary" id="btnSendClue">üì° Send</button>

          <label class="btn" style="gap:10px;">
            <input type="checkbox" id="timerOn" style="accent-color: var(--blue); transform: scale(1.05);" />
            Use Timer
          </label>

          <div class="field" style="width:160px; flex:0 0 160px;">
            <span style="opacity:.9;">‚è±Ô∏è</span>
            <input id="secInput" type="number" min="10" max="600" placeholder="Seconds" />
          </div>
        </div>

        <div class="hint">
          Rules: One-word clue. Do not use a board word (or part of it). Number is required.
        </div>
      </div>
    </div>

    <main class="board" id="board"></main>
  </div>

  <!-- START / MAIN MENU -->
  <div class="overlay show" id="startOverlay">
    <div class="modal">
      <h2>IT SUPPORT ACADEMY</h2>
      <p>Code Mission ‚Äî fast and clean. Use one device for players. Spymasters use phones.</p>

      <div class="row">
        <button class="btn good" id="btnStart">‚ñ∂ Start Mission</button>
        <button class="btn primary" id="btnSpyAccess">üîê Spymaster Access</button>
      </div>

      <div class="hint">
        Tip: Open with <b>?room=CLASS1</b> or <b>?room=CLASS1&role=spymaster&team=blue</b>
      </div>
    </div>
  </div>

  <!-- SPY TEAM SELECT -->
  <div class="overlay" id="spySelectOverlay">
    <div class="modal">
      <h2>Spymaster Access</h2>
      <p>Select your team.</p>
      <div class="row">
        <button class="btn primary" id="btnPickBlue">üîµ Blue Team</button>
        <button class="btn danger"  id="btnPickRed">üî¥ Red Team</button>
        <button class="btn" id="btnSpyBack">‚¨Ö Back</button>
      </div>
    </div>
  </div>

  <!-- PASSWORD -->
  <div class="overlay" id="pwOverlay">
    <div class="modal">
      <h2 id="pwTitle">Enter Password</h2>
      <p id="pwDesc">This area is private.</p>
      <div class="row">
        <div class="field" style="flex:1 1 220px;">
          <span style="opacity:.9;">üîë</span>
          <input id="pwInput" type="password" placeholder="PASSWORD" />
        </div>
        <button class="btn primary" id="btnPwEnter">Start</button>
        <button class="btn" id="btnPwBack">‚¨Ö Back</button>
      </div>
      <div class="hint" id="pwHint">A wrong password will be denied.</div>
    </div>
  </div>

  <!-- TURN LOCK for spymaster when not their turn -->
  <div class="lockScreen" id="turnLock">
    <div class="modal" style="text-align:center;">
      <h2>Locked</h2>
      <p>Wait for your turn.</p>
      <div class="row" style="justify-content:center;">
        <button class="btn" id="btnLockOk">OK</button>
      </div>
    </div>
  </div>

  <!-- END SCREEN -->
  <div class="endFull" id="endScreen">
    <div class="endCard">
      <h1 id="endTitle">‚Äî</h1>
      <p id="endSub">‚Äî</p>
      <div id="perfectLine" style="display:none; font-weight:1000; margin: 0 0 12px;">üèÜ PERFECT EXECUTION</div>
      <div class="endBtns">
        <button class="btn good" id="btnPlayAgain">üîÅ Play Again</button>
        <button class="btn primary" id="btnReturnMain">üè† Return to Main Menu</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">‚Äî</div>

  <!-- Firebase (v10+) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot,
      serverTimestamp, runTransaction
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    // ====== CONFIG ======
    const FIREBASE_CONFIG = {
      // üî• Paste your Firebase config here
      apiKey: "PASTE_ME",
      authDomain: "PASTE_ME",
      projectId: "PASTE_ME",
      storageBucket: "PASTE_ME",
      messagingSenderId: "PASTE_ME",
      appId: "PASTE_ME",
    };

    // Team passwords (change these)
    const TEAM_PASSWORDS = {
      blue: "BLUE123",
      red:  "RED123",
    };

    // Words (IT Support theme). Keep 25.
    const WORDS = [
      "SERVER","ROUTER","SWITCH","FIREWALL","BACKUP",
      "CLOUD","TICKET","PASSWORD","MONITOR","PRINTER",
      "MOUSE","KEYBOARD","VIRUS","PATCH","UPDATE",
      "DNS","WIFI","CABLE","ACCOUNT","LOGIN",
      "ACCESS","DATABASE","DRIVER","PORT","SCAN"
    ];

    // Small icons (lightweight). Mapped by keyword fallback.
    const ICONS = {
      SERVER:"üóÑÔ∏è", ROUTER:"üì°", SWITCH:"üîÄ", FIREWALL:"üõ°Ô∏è", BACKUP:"üíæ",
      CLOUD:"‚òÅÔ∏è", TICKET:"üé´", PASSWORD:"üîë", MONITOR:"üñ•Ô∏è", PRINTER:"üñ®Ô∏è",
      MOUSE:"üñ±Ô∏è", KEYBOARD:"‚å®Ô∏è", VIRUS:"ü¶†", PATCH:"ü©π", UPDATE:"‚¨ÜÔ∏è",
      DNS:"üåê", WIFI:"üì∂", CABLE:"üîå", ACCOUNT:"üë§", LOGIN:"‚û°Ô∏è",
      ACCESS:"‚úÖ", DATABASE:"üóÉÔ∏è", DRIVER:"üöó", PORT:"üö™", SCAN:"üîé"
    };

    // Distribution (classic): 9 vs 8 + 7 neutral + 1 assassin
    const DIST = { blue: 9, red: 8, neu: 7, ass: 1 };

    // ====== APP INIT ======
    const app = initializeApp(FIREBASE_CONFIG);
    const db = getFirestore(app);

    // ====== UI refs ======
    const qs = (id) => document.getElementById(id);
    const boardEl = qs("board");

    const bluePill = qs("bluePill");
    const redPill  = qs("redPill");
    const blueLeftEl = qs("blueLeft");
    const redLeftEl  = qs("redLeft");

    const clueTextEl = qs("clueText");
    const clueNumEl = qs("clueNum");
    const guessesLeftEl = qs("guessesLeft");

    const thinkingTextEl = qs("thinkingText");
    const timerTextEl = qs("timerText");
    const timerCountdownEl = qs("timerCountdown");
    const timerFillEl = qs("timerFill");

    const spyPanelEl = qs("spyPanel");
    const spyTeamPillEl = qs("spyTeamPill");
    const clueInput = qs("clueInput");
    const numInput  = qs("numInput");
    const timerOnEl = qs("timerOn");
    const secInput  = qs("secInput");
    const btnSendClue = qs("btnSendClue");

    const startOverlay = qs("startOverlay");
    const spySelectOverlay = qs("spySelectOverlay");
    const pwOverlay = qs("pwOverlay");
    const pwTitle = qs("pwTitle");
    const pwDesc  = qs("pwDesc");
    const pwInput = qs("pwInput");
    const turnLock = qs("turnLock");

    const endScreen = qs("endScreen");
    const endTitle = qs("endTitle");
    const endSub = qs("endSub");
    const perfectLine = qs("perfectLine");

    const toast = qs("toast");
    const momentumBanner = qs("momentumBanner");
    const finalBanner = qs("finalBanner");

    // buttons
    const btnStart = qs("btnStart");
    const btnSpyAccess = qs("btnSpyAccess");
    const btnPickBlue = qs("btnPickBlue");
    const btnPickRed  = qs("btnPickRed");
    const btnSpyBack  = qs("btnSpyBack");
    const btnPwEnter  = qs("btnPwEnter");
    const btnPwBack   = qs("btnPwBack");
    const btnLockOk   = qs("btnLockOk");

    const btnPlayAgain = qs("btnPlayAgain");
    const btnReturnMain = qs("btnReturnMain");
    const btnMain = qs("btnMain");

    const btnFullscreen = qs("btnFullscreen");
    const btnSilent = qs("btnSilent");

    // ====== URL params / mode ======
    const params = new URLSearchParams(location.search);
    const ROOM = (params.get("room") || "CLASS1").trim();
    const ROLE = (params.get("role") || "board").toLowerCase(); // board | spymaster
    const TEAM = (params.get("team") || "").toLowerCase();      // blue | red
    qs("roomLabel").textContent = `ROOM: ${ROOM}`;

    let isSpymaster = (ROLE === "spymaster");
    let myTeam = (TEAM === "blue" || TEAM === "red") ? TEAM : null;

    // ====== Sound (light click) ======
    let soundOn = true;
    const audioCtx = (() => {
      try { return new (window.AudioContext || window.webkitAudioContext)(); }
      catch { return null; }
    })();

    function playClick(){
      if(!soundOn || !audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "square";
      o.frequency.setValueAtTime(520, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.06, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t); o.stop(t + 0.07);
    }

    btnSilent.addEventListener("click", () => {
      soundOn = !soundOn;
      btnSilent.textContent = soundOn ? "üîä Sound ON" : "üîá Silent Mode";
      toastMsg(soundOn ? "Sound ON" : "Silent Mode");
    });

    // Fullscreen
    btnFullscreen.addEventListener("click", async () => {
      try{
        if(!document.fullscreenElement){
          await document.documentElement.requestFullscreen();
          toastMsg("Full Screen ON");
        }else{
          await document.exitFullscreen();
          toastMsg("Full Screen OFF");
        }
      }catch{
        toastMsg("Fullscreen not available");
      }
    });

    // ====== Firestore refs ======
    const roomRef = doc(db, "rooms", ROOM);
    const stateRef = doc(db, "rooms", ROOM, "state", "current");

    // ====== Game state (local cache) ======
    let state = null;
    let unsub = null;
    let timerTick = null;

    // streak for Momentum (per turn, per team)
    let turnStreak = 0;
    // perfect execution flags
    let perfect = { blue: true, red: true };

    // ====== Helpers ======
    const shuffle = (arr) => {
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    };

    function toastMsg(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 1400);
    }

    function normalizeWord(s){
      return (s || "")
        .toUpperCase()
        .trim()
        .replace(/[^A-Z0-9]/g, ""); // keep letters/numbers only
    }

    // ====== Clue rules (Codenames-like) ======
    function validateClue(clueRaw, num, boardWords){
      const clue = (clueRaw || "").trim();
      if(!clue) return "Write a clue.";
      if(clue.includes(" ")) return "Clue must be one word.";
      const clean = normalizeWord(clue);
      if(clean.length < 2) return "Clue is too short.";
      if(!Number.isInteger(num) || num < 1 || num > 9) return "Number must be 1 to 9.";

      // Disallow clue being a board word or close match/part.
      const bw = boardWords.map(w => normalizeWord(w));
      if(bw.includes(clean)) return "Clue cannot be a board word.";

      // No using part of a board word, and no board word as part of clue.
      for(const w of bw){
        if(!w) continue;
        if(w.includes(clean) || clean.includes(w)){
          return "Clue cannot use part of a board word.";
        }
      }

      // Disallow pure numbers/letters like "A" or "123"
      if(/^\d+$/.test(clean)) return "Clue cannot be only numbers.";
      if(/^[A-Z]$/.test(clean)) return "Clue cannot be one letter.";

      return null;
    }

    // ====== Build new game ======
    function buildNewGame(){
      const words = shuffle(WORDS).slice(0,25);
      const types = shuffle([
        ...Array(DIST.blue).fill("blue"),
        ...Array(DIST.red).fill("red"),
        ...Array(DIST.neu).fill("neu"),
        ...Array(DIST.ass).fill("ass"),
      ]);

      const cards = words.map((w,i)=>({
        id: i,
        word: w,
        type: types[i],
        revealed: false
      }));

      return {
        v: 1,
        createdAt: Date.now(),
        // turn
        turnTeam: "blue", // start with blue by default
        // clue
        clueText: "‚Äî",
        clueNum: null,
        guessesLeft: null,
        // counts
        left: {
          blue: DIST.blue,
          red:  DIST.red
        },
        // timer
        timer: {
          enabled: false,
          seconds: 0,
          endsAt: null
        },
        // meta
        status: "playing", // playing | ended
        winner: null,      // blue | red | loss_assassin
        perfect: { blue: true, red: true },
        // cards
        cards
      };
    }

    async function ensureRoom(){
      const snap = await getDoc(stateRef);
      if(!snap.exists()){
        await setDoc(stateRef, {
          ...buildNewGame(),
          updatedAt: serverTimestamp()
        });
      }
    }

    // ====== UI render ======
    function setTeamPills(turnTeam){
      bluePill.classList.toggle("active", turnTeam === "blue");
      bluePill.classList.toggle("blue", true);
      redPill.classList.toggle("active", turnTeam === "red");
      redPill.classList.toggle("red", true);
    }

    function setThinkingMode(){
      // If there is a clue and guesses left > 0, and nobody has clicked this turn yet:
      // We approximate: if guessesLeft == clueNum, then no correct click yet.
      if(state?.status !== "playing" || !state?.clueNum || !state?.guessesLeft){
        thinkingTextEl.textContent = "‚Äî";
        return;
      }
      if(state.guessesLeft === state.clueNum){
        thinkingTextEl.textContent = "Strategizing‚Ä¶";
      }else{
        thinkingTextEl.textContent = "‚Äî";
      }
    }

    function showMomentum(){
      momentumBanner.classList.add("show");
      setTimeout(()=>momentumBanner.classList.remove("show"), 1200);
    }

    function checkFinalTargetBanner(){
      const t = state?.turnTeam;
      if(!t) return;
      const left = state.left?.[t];
      if(left === 1){
        finalBanner.classList.add("show");
      }else{
        finalBanner.classList.remove("show");
      }
    }

    function renderHUD(){
      if(!state) return;

      blueLeftEl.textContent = String(state.left.blue);
      redLeftEl.textContent  = String(state.left.red);

      clueTextEl.textContent = state.clueText || "‚Äî";
      clueNumEl.textContent  = state.clueNum ?? "‚Äî";
      guessesLeftEl.textContent = state.guessesLeft ?? "‚Äî";

      setTeamPills(state.turnTeam);
      checkFinalTargetBanner();
      setThinkingMode();

      // timer UI
      if(state.timer?.enabled && state.timer?.endsAt){
        timerTextEl.textContent = "Timer ON";
      }else{
        timerTextEl.textContent = "Timer OFF";
        timerCountdownEl.textContent = "‚Äî";
        timerFillEl.style.transform = "scaleY(1)";
      }

      // spymaster panel visibility
      spyPanelEl.style.display = (isSpymaster ? "block" : "none");
      if(isSpymaster){
        spyTeamPillEl.textContent = (myTeam || "TEAM").toUpperCase();
        spyTeamPillEl.classList.toggle("blue", myTeam === "blue");
        spyTeamPillEl.classList.toggle("red", myTeam === "red");
      }
    }

    function cardIcon(word){
      return ICONS[word] || "üß∞";
    }

    function renderBoard(){
      if(!state) return;

      boardEl.innerHTML = "";
      for(const c of state.cards){
        const div = document.createElement("div");
        div.className = "card";
        div.dataset.id = String(c.id);

        const word = document.createElement("div");
        word.className = "word";
        word.textContent = c.word;

        const icon = document.createElement("div");
        icon.className = "icon";
        icon.textContent = cardIcon(c.word);

        // Spymaster sees color map tint (before reveal)
        if(isSpymaster && !c.revealed){
          const tint = document.createElement("div");
          tint.className = `spyTint ${c.type}`;
          div.appendChild(tint);
        }

        // Revealed styling for everyone
        if(c.revealed){
          div.classList.add("revealed");
          div.classList.add(c.type); // blue/red/neu/ass
        }

        // Lock click for spymaster always
        if(isSpymaster){
          div.classList.add("locked");
        }

        div.appendChild(word);
        div.appendChild(icon);

        // click handler (board only)
        div.addEventListener("click", () => onCardClick(c.id));

        boardEl.appendChild(div);
      }
    }

    // ====== Timer local tick (based on endsAt only) ======
    function startTimerTick(){
      if(timerTick) clearInterval(timerTick);
      timerTick = setInterval(()=>{
        if(!state?.timer?.enabled || !state.timer.endsAt || state.status !== "playing") return;
        const msLeft = state.timer.endsAt - Date.now();
        const s = Math.max(0, Math.ceil(msLeft/1000));
        timerCountdownEl.textContent = `${s}s`;

        const total = Math.max(1, state.timer.seconds || 1);
        const frac = Math.max(0, Math.min(1, msLeft/(total*1000)));
        timerFillEl.style.transform = `scaleY(${frac})`;

        // When timer ends, auto switch turn (no extra server writes here; we do one server write via transaction)
        if(msLeft <= 0){
          autoEndTurnByTimer().catch(()=>{});
        }
      }, 200);
    }

    async function autoEndTurnByTimer(){
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(stateRef);
        if(!snap.exists()) return;
        const st = snap.data();
        if(st.status !== "playing") return;
        if(!st.timer?.enabled || !st.timer?.endsAt) return;
        if(st.timer.endsAt > Date.now()) return;

        const next = st.turnTeam === "blue" ? "red" : "blue";
        tx.update(stateRef, {
          turnTeam: next,
          clueText: "‚Äî",
          clueNum: null,
          guessesLeft: null,
          timer: { enabled:false, seconds:0, endsAt:null },
          updatedAt: serverTimestamp()
        });
      });
    }

    // ====== Game logic ======
    async function onCardClick(cardId){
      // players device only can click
      if(isSpymaster) return;
      if(!state || state.status !== "playing") return;

      const card = state.cards.find(x=>x.id===cardId);
      if(!card || card.revealed) return;

      playClick();

      await runTransaction(db, async (tx) => {
        const snap = await tx.get(stateRef);
        if(!snap.exists()) return;
        const st = snap.data();
        if(st.status !== "playing") return;

        const cards = st.cards || [];
        const idx = cards.findIndex(x=>x.id===cardId);
        if(idx < 0) return;
        if(cards[idx].revealed) return;

        const clicked = cards[idx];
        clicked.revealed = true;
        cards[idx] = clicked;

        const curTeam = st.turnTeam;
        const nextTeam = (curTeam === "blue") ? "red" : "blue";

        let leftBlue = st.left.blue;
        let leftRed  = st.left.red;

        let guessesLeft = st.guessesLeft;
        let clueNum = st.clueNum;

        // turn streak (server-side minimal): we keep local streak, but server decides transitions.
        // We'll implement momentum purely client-side using heuristics after snapshot updates.
        // Perfect execution: if a team ends a turn by wrong/neutral, that team is no longer perfect.
        let perfectObj = st.perfect || { blue:true, red:true };

        // Update counts and turn rules
        let endNow = false;
        let reason = "continue";

        if(clicked.type === "ass"){
          // immediate end game (loss)
          tx.update(stateRef, {
            cards,
            status: "ended",
            winner: "loss_assassin",
            updatedAt: serverTimestamp()
          });
          return;
        }

        if(clicked.type === "blue"){
          leftBlue = Math.max(0, leftBlue - 1);
          if(curTeam !== "blue"){
            // wrong team clicked => end turn
            perfectObj[curTeam] = false;
            endNow = true; reason = "wrong";
          }else{
            // correct
            if(typeof guessesLeft === "number") guessesLeft = Math.max(0, guessesLeft - 1);
            if(guessesLeft === 0) endNow = true; reason = "done";
          }
        } else if(clicked.type === "red"){
          leftRed = Math.max(0, leftRed - 1);
          if(curTeam !== "red"){
            perfectObj[curTeam] = false;
            endNow = true; reason = "wrong";
          }else{
            if(typeof guessesLeft === "number") guessesLeft = Math.max(0, guessesLeft - 1);
            if(guessesLeft === 0) endNow = true; reason = "done";
          }
        } else if(clicked.type === "neu"){
          // neutral ends turn
          perfectObj[curTeam] = false;
          endNow = true; reason = "neutral";
        }

        // check win
        if(leftBlue === 0){
          tx.update(stateRef, {
            cards,
            left: { blue:leftBlue, red:leftRed },
            status: "ended",
            winner: "blue",
            perfect: perfectObj,
            updatedAt: serverTimestamp()
          });
          return;
        }
        if(leftRed === 0){
          tx.update(stateRef, {
            cards,
            left: { blue:leftBlue, red:leftRed },
            status: "ended",
            winner: "red",
            perfect: perfectObj,
            updatedAt: serverTimestamp()
          });
          return;
        }

        // end turn if needed
        if(endNow){
          tx.update(stateRef, {
            cards,
            left: { blue:leftBlue, red:leftRed },
            turnTeam: nextTeam,
            clueText: "‚Äî",
            clueNum: null,
            guessesLeft: null,
            timer: { enabled:false, seconds:0, endsAt:null },
            perfect: perfectObj,
            updatedAt: serverTimestamp()
          });
          return;
        }

        // continue same turn
        tx.update(stateRef, {
          cards,
          left: { blue:leftBlue, red:leftRed },
          guessesLeft: guessesLeft,
          perfect: perfectObj,
          updatedAt: serverTimestamp()
        });
      });
    }

    // ====== Spymaster send clue ======
    btnSendClue.addEventListener("click", async () => {
      if(!isSpymaster || !state || state.status !== "playing") return;

      // lock if not your turn
      if(state.turnTeam !== myTeam){
        lockIfNotMyTurn();
        return;
      }

      const clue = clueInput.value;
      const num  = Number(numInput.value);

      // enforce clue rules
      const boardWords = (state.cards || []).map(c=>c.word);
      const err = validateClue(clue, num, boardWords);
      if(err){
        toastMsg(err);
        return;
      }

      const useTimer = timerOnEl.checked;
      const secs = Number(secInput.value || 0);

      // timer optional
      let timer = { enabled:false, seconds:0, endsAt:null };
      if(useTimer){
        const s = Math.max(10, Math.min(600, Number.isInteger(secs) ? secs : 60));
        timer = { enabled:true, seconds:s, endsAt: Date.now() + s*1000 };
      }

      // send
      await setDoc(stateRef, {
        clueText: clue.trim().toUpperCase(),
        clueNum: num,
        guessesLeft: num,
        timer,
        updatedAt: serverTimestamp()
      }, { merge:true });

      // UI feedback
      toastMsg("üì° Code Sent");
    });

    function lockIfNotMyTurn(){
      // show lock overlay for spymaster when not their turn
      turnLock.classList.add("show");
      btnSendClue.disabled = true;
      clueInput.disabled = true;
      numInput.disabled = true;
      timerOnEl.disabled = true;
      secInput.disabled = true;
    }

    function unlockIfMyTurn(){
      turnLock.classList.remove("show");
      btnSendClue.disabled = false;
      clueInput.disabled = false;
      numInput.disabled = false;
      timerOnEl.disabled = false;
      secInput.disabled = false;
    }

    btnLockOk.addEventListener("click", ()=> turnLock.classList.remove("show"));

    // ====== End screen ======
    function showEnd(winner){
      endScreen.classList.add("show");
      endScreen.classList.remove("blueWin","redWin","loss");

      perfectLine.style.display = "none";

      if(winner === "blue"){
        endScreen.classList.add("blueWin");
        endTitle.textContent = "MISSION SUCCESS";
        endSub.textContent = "BLUE TEAM WINS";
        if(state?.perfect?.blue) perfectLine.style.display = "block";
      } else if(winner === "red"){
        endScreen.classList.add("redWin");
        endTitle.textContent = "MISSION SUCCESS";
        endSub.textContent = "RED TEAM WINS";
        if(state?.perfect?.red) perfectLine.style.display = "block";
      } else {
        endScreen.classList.add("loss");
        endTitle.textContent = "SYSTEM BREACH";
        endSub.textContent = "MISSION TERMINATED";
      }
    }

    function hideEnd(){
      endScreen.classList.remove("show","blueWin","redWin","loss");
      perfectLine.style.display = "none";
    }

    btnPlayAgain.addEventListener("click", async ()=>{
      playClick();
      hideEnd();
      // reset game in same room
      await setDoc(stateRef, { ...buildNewGame(), updatedAt: serverTimestamp() });
      toastMsg("New Mission");
    });

    btnReturnMain.addEventListener("click", ()=>{
      playClick();
      hideEnd();
      startOverlay.classList.add("show");
    });

    btnMain.addEventListener("click", ()=>{
      playClick();
      startOverlay.classList.add("show");
    });

    // ====== Start / Access flow ======
    btnStart.addEventListener("click", async ()=>{
      playClick();
      startOverlay.classList.remove("show");
      await connect();
    });

    btnSpyAccess.addEventListener("click", ()=>{
      playClick();
      spySelectOverlay.classList.add("show");
      startOverlay.classList.remove("show");
    });

    btnSpyBack.addEventListener("click", ()=>{
      playClick();
      spySelectOverlay.classList.remove("show");
      startOverlay.classList.add("show");
    });

    let pendingTeam = null;

    btnPickBlue.addEventListener("click", ()=>{
      playClick();
      pendingTeam = "blue";
      openPasswordModal("Blue Team Password");
    });

    btnPickRed.addEventListener("click", ()=>{
      playClick();
      pendingTeam = "red";
      openPasswordModal("Red Team Password");
    });

    function openPasswordModal(title){
      spySelectOverlay.classList.remove("show");
      pwOverlay.classList.add("show");
      pwTitle.textContent = title;
      pwDesc.textContent = "Enter password to open the Spymaster panel.";
      pwInput.value = "";
      pwInput.focus();
    }

    btnPwBack.addEventListener("click", ()=>{
      playClick();
      pwOverlay.classList.remove("show");
      spySelectOverlay.classList.add("show");
    });

    btnPwEnter.addEventListener("click", ()=>{
      playClick();
      const pw = pwInput.value.trim();
      if(!pendingTeam) return;
      if(pw !== TEAM_PASSWORDS[pendingTeam]){
        toastMsg("Access Denied");
        return;
      }

      // switch this client into spymaster mode (local only)
      isSpymaster = true;
      myTeam = pendingTeam;
      pwOverlay.classList.remove("show");
      startOverlay.classList.remove("show");

      // update URL (no reload)
      const url = new URL(location.href);
      url.searchParams.set("room", ROOM);
      url.searchParams.set("role","spymaster");
      url.searchParams.set("team", myTeam);
      history.replaceState({}, "", url.toString());

      connect().catch(()=>{});
      toastMsg("Spymaster Mode");
    });

    // ====== Momentum + code received animations (light) ======
    let lastClueStamp = "";
    let lastGuessesLeft = null;

    function afterSnapshotEffects(prev, cur){
      // Code received effect (when clue changes from ‚Äî to word)
      const curKey = `${cur.clueText}|${cur.clueNum}|${cur.turnTeam}`;
      if(cur.clueText && cur.clueText !== "‚Äî" && curKey !== lastClueStamp){
        lastClueStamp = curKey;
        toastMsg("üì° Code Received");
        // reset streak for new clue
        turnStreak = 0;
        lastGuessesLeft = cur.guessesLeft;
      }

      // Momentum: when guessesLeft decreases by 1 due to correct picks
      if(typeof lastGuessesLeft === "number" && typeof cur.guessesLeft === "number"){
        if(cur.guessesLeft < lastGuessesLeft){
          // correct pick happened
          turnStreak += 1;
          if(turnStreak >= 2){
            showMomentum();
          }
        }
        // reset on turn change or clue reset
        if(prev && prev.turnTeam !== cur.turnTeam) turnStreak = 0;
        if(cur.clueText === "‚Äî") turnStreak = 0;
      }
      lastGuessesLeft = cur.guessesLeft;
    }

    // ====== Connect realtime ======
    async function connect(){
      await ensureRoom();

      if(unsub) unsub();
      unsub = onSnapshot(stateRef, (snap)=>{
        if(!snap.exists()) return;

        const prev = state;
        state = snap.data();

        // spymaster turn lock
        if(isSpymaster && myTeam){
          if(state.turnTeam !== myTeam && state.status === "playing"){
            lockIfNotMyTurn();
          }else{
            unlockIfMyTurn();
          }
        }

        renderHUD();
        renderBoard();

        afterSnapshotEffects(prev, state);

        // timer tick (local)
        startTimerTick();

        // ended?
        if(state.status === "ended"){
          if(state.winner === "blue" || state.winner === "red"){
            showEnd(state.winner);
          }else{
            showEnd("loss");
          }
        }else{
          hideEnd();
        }
      });
    }

    // ====== Boot ======
    // Auto-connect if opened directly in a role link
    (async ()=>{
      // Show start screen by default. If link has role or room explicitly, auto-start.
      const hasDirect = params.has("room") || params.has("role");
      if(hasDirect){
        startOverlay.classList.remove("show");
        await connect();
      }else{
        startOverlay.classList.add("show");
      }
    })();

  </script>
</body>
</html>
