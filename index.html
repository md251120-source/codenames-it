<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Codenames ‚Äî IT Support</title>

  <style>
    :root{
      --bg0:#070A12;
      --bg1:#0B1020;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.12);
      --text:#EAF0FF;
      --muted: rgba(234,240,255,.72);

      --blue:#4EA2FF;
      --red:#FF5A76;
      --neutral:#B9C0D3;
      --black:#000;

      --shadow: 0 18px 55px rgba(0,0,0,.45);
      --radius: 18px;

      --cardText:#F2F6FF;
      --cardTextDim: rgba(242,246,255,.82);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 700px at 20% 10%, rgba(78,162,255,.18), transparent 60%),
                  radial-gradient(1000px 650px at 80% 20%, rgba(255,90,118,.16), transparent 62%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* slow background motion (NO FLASH) */
    body::before{
      content:"";
      position:fixed;
      inset:-40%;
      background:
        radial-gradient(600px 420px at 30% 40%, rgba(78,162,255,.10), transparent 60%),
        radial-gradient(650px 450px at 70% 55%, rgba(255,90,118,.09), transparent 62%),
        repeating-linear-gradient(90deg, rgba(255,255,255,.04) 0 1px, transparent 1px 140px);
      filter: blur(0px);
      transform: translate3d(0,0,0);
      animation: bgDrift 28s linear infinite;
      pointer-events:none;
      opacity:.85;
    }
    @keyframes bgDrift{
      from{ transform: translate3d(-2%, -1%, 0); }
      to  { transform: translate3d( 2%,  1%, 0); }
    }

    .app{
      max-width: 1220px;
      margin: 0 auto;
      padding: 16px 16px 34px;
    }

    .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 280px;
    }
    .logo{
      width:54px; height:54px;
      border-radius:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      border:1px solid var(--stroke);
      box-shadow: var(--shadow);
      display:grid; place-items:center;
      font-size:26px;
    }
    .title{ display:flex; flex-direction:column; gap:4px; }
    h1{
      margin:0;
      font-size: 22px;
      letter-spacing: .3px;
      font-weight: 900;
    }
    .meta{
      display:flex; gap:10px; flex-wrap:wrap;
      color:var(--muted);
      font-weight: 800;
      font-size: 12.5px;
    }
    .dot{ opacity:.5; }

    .right{
      display:flex;
      align-items:flex-end;
      justify-content:flex-end;
      gap:10px;
      flex-direction:column;
      flex:1;
      min-width: 320px;
    }

    .chips{
      display:flex;
      flex-wrap:wrap;
      justify-content:flex-end;
      gap:8px;
    }

    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      font-weight: 900;
      font-size: 13px;
      box-shadow: 0 12px 35px rgba(0,0,0,.25);
      white-space: nowrap;
    }
    .chip b{ font-size: 14px; }
    .chip.blue b{ color: var(--blue); }
    .chip.red b{ color: var(--red); }
    .chip.neu b{ color: var(--neutral); }

    .actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      cursor:pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 35px rgba(0,0,0,.25);
    }
    .btn.primary{
      border-color: rgba(78,162,255,.35);
      background: linear-gradient(180deg, rgba(78,162,255,.26), rgba(78,162,255,.10));
    }
    .btn.danger{
      border-color: rgba(255,90,118,.35);
      background: linear-gradient(180deg, rgba(255,90,118,.22), rgba(255,90,118,.08));
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    /* clue bar */
    .clueBar{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
    }
    .clueCard{
      flex: 1;
      min-width: 320px;
      background: var(--panel2);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      padding: 12px 14px;
      display:flex;
      align-items:center;
      gap:12px;
    }
    .clueLabel{
      color: var(--muted);
      font-weight: 900;
      font-size: 12px;
      letter-spacing:.4px;
      text-transform: uppercase;
      width: 54px;
    }
    .clueText{
      flex:1;
      font-weight: 950;
      letter-spacing: .7px;
      font-size: 18px;
      color: var(--text);
    }
    .numBox{
      width: 46px; height: 46px;
      border-radius: 14px;
      display:grid; place-items:center;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      font-weight: 950;
      font-size: 16px;
    }
    .guessInfo{
      display:flex; align-items:center; gap:10px;
      margin-left:auto;
      color: var(--muted);
      font-weight: 900;
    }
    .guessInfo b{
      color: var(--text);
      font-size: 16px;
    }

    /* spymaster panel */
    .smPanel{
      flex: 1;
      min-width: 360px;
      background: var(--panel2);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      padding: 12px 14px;
      display:none;
    }
    .smHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .smHeader .tag{
      font-weight: 950;
      font-size: 13px;
      color: var(--muted);
    }
    .smHeader .teamPill{
      padding:6px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      font-weight: 950;
      font-size: 12px;
    }

    .smRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .smRow input{
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      outline:none;
    }
    .smRow input::placeholder{ color: rgba(234,240,255,.45); }
    #clueInput{ flex:1; min-width: 180px; }
    #numInput{ width: 120px; }
    #secInput{ width: 140px; }

    .timerRow{
      margin-top:10px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .toggle{
      display:flex; align-items:center; gap:8px;
      font-weight: 950;
      color: var(--muted);
      user-select:none;
    }

    /* timer circle */
    .timerCircle{
      width:44px; height:44px;
      border-radius: 50%;
      border: 1px solid var(--stroke);
      background: conic-gradient(rgba(78,162,255,.75) 0deg, rgba(255,255,255,.10) 0deg);
      display:grid; place-items:center;
      font-weight: 950;
      font-size: 12px;
      color: var(--text);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }

    /* board */
    .board{
      margin-top: 14px;
      display:grid;
      grid-template-columns: repeat(5, minmax(140px, 1fr));
      gap: 12px;
    }
    @media (max-width: 980px){
      .board{ grid-template-columns: repeat(4, minmax(140px, 1fr)); }
    }
    @media (max-width: 760px){
      .board{ grid-template-columns: repeat(3, minmax(140px, 1fr)); }
    }
    @media (max-width: 520px){
      .board{ grid-template-columns: repeat(2, minmax(140px, 1fr)); }
    }

    .card{
      position:relative;
      border-radius: 18px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      box-shadow: 0 16px 38px rgba(0,0,0,.35);
      padding: 16px 14px 14px;
      cursor:pointer;
      text-align:center;
      user-select:none;
      min-height: 72px;

      /* keep it smooth but NOT flashy */
      transition: transform .10s ease, background-color .12s ease, border-color .12s ease;
    }
    .card:hover{ transform: translateY(-1px); }
    .card:active{ transform: translateY(0); }

    .word{
      font-weight: 950;
      letter-spacing: .3px;
      font-size: 16px;
      color: var(--cardText);
      text-shadow: 0 2px 10px rgba(0,0,0,.4);
    }

    /* tiny IT icon */
    .icon{
      position:absolute;
      left: 10px;
      top: 10px;
      font-size: 14px;
      opacity: .88;
      filter: drop-shadow(0 6px 16px rgba(0,0,0,.35));
    }

    /* spymaster hint border */
    .hint.blue{ border-color: rgba(78,162,255,.55); }
    .hint.red{ border-color: rgba(255,90,118,.55); }
    .hint.neutral{ border-color: rgba(185,192,211,.45); }
    .hint.assassin{ border-color: rgba(255,255,255,.25); }

    /* revealed */
    .revealed.blue{
      background: linear-gradient(180deg, rgba(78,162,255,.78), rgba(78,162,255,.55));
      border-color: rgba(78,162,255,.75);
    }
    .revealed.red{
      background: linear-gradient(180deg, rgba(255,90,118,.76), rgba(255,90,118,.54));
      border-color: rgba(255,90,118,.72);
    }
    .revealed.neutral{
      background: linear-gradient(180deg, rgba(185,192,211,.42), rgba(185,192,211,.26));
      border-color: rgba(185,192,211,.45);
    }
    .revealed.assassin{
      background: linear-gradient(180deg, rgba(0,0,0,.88), rgba(0,0,0,.70));
      border-color: rgba(255,255,255,.22);
    }

    /* near victory glow (subtle, no flashing) */
    .nearVictoryBlue body{}
    .nearVictory{
      position: fixed;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity .25s ease;
    }
    .nearVictory.on{ opacity:1; }
    .nearVictory.blue{
      background: radial-gradient(900px 500px at 30% 20%, rgba(78,162,255,.16), transparent 60%);
    }
    .nearVictory.red{
      background: radial-gradient(900px 500px at 70% 25%, rgba(255,90,118,.14), transparent 60%);
    }

    /* start gate */
    .gate{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.62);
      backdrop-filter: blur(10px);
      z-index: 9999;
      padding: 16px;
    }
    .gate .box{
      width: min(520px, 100%);
      border-radius: 22px;
      border: 1px solid var(--stroke);
      background: rgba(10,12,18,.82);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .gate h2{
      margin: 0 0 10px;
      font-size: 20px;
      font-weight: 950;
    }
    .gate p{
      margin: 0 0 12px;
      color: var(--muted);
      font-weight: 850;
      font-size: 13px;
      line-height: 1.35;
    }
    .gate .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .gate input{
      flex:1;
      min-width: 220px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      color: var(--text);
      padding: 12px 12px;
      border-radius: 14px;
      font-weight: 900;
      outline:none;
    }

    /* end overlay */
    .overlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10000;
      padding: 16px;
      background: rgba(0,0,0,.66);
      backdrop-filter: blur(12px);
    }
    .overlay .panel{
      width: min(980px, 100%);
      border-radius: 26px;
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .overlay .hero{
      min-height: 260px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 16px;
      padding: 18px;
    }
    .overlay .hero.blue{
      background: radial-gradient(900px 460px at 20% 25%, rgba(78,162,255,.35), transparent 60%),
                  linear-gradient(180deg, rgba(78,162,255,.30), rgba(10,12,18,.85));
    }
    .overlay .hero.red{
      background: radial-gradient(900px 460px at 80% 25%, rgba(255,90,118,.32), transparent 60%),
                  linear-gradient(180deg, rgba(255,90,118,.28), rgba(10,12,18,.85));
    }
    .overlay .hero.black{
      background: linear-gradient(180deg, rgba(0,0,0,.92), rgba(10,12,18,.92));
    }
    .overlay .titleBlock{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding: 10px 6px;
    }
    .overlay h3{
      margin:0;
      font-size: 34px;
      font-weight: 1000;
      letter-spacing: .6px;
    }
    .overlay .sub{
      margin:0;
      color: rgba(234,240,255,.80);
      font-weight: 850;
      font-size: 14px;
    }
    .overlay .footer{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 14px;
      border-top: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
    }

    /* robots (inline SVG containers) */
    .robotWrap{
      width: 320px;
      max-width: 40vw;
      opacity: .95;
      filter: drop-shadow(0 18px 45px rgba(0,0,0,.55));
    }
    @media (max-width: 720px){
      .overlay .hero{ flex-direction:column; align-items:flex-start; }
      .robotWrap{ width: 300px; max-width: 85vw; }
    }

    /* reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce){
      body::before{ animation:none; }
      .card{ transition:none; }
    }
  </style>
</head>

<body>
  <div class="nearVictory blue" id="nearBlue"></div>
  <div class="nearVictory red" id="nearRed"></div>

  <div class="app">
    <header class="top">
      <div class="brand">
        <div class="logo">üõ†Ô∏è</div>
        <div class="title">
          <h1>CODENAMES ‚Äî IT SUPPORT</h1>
          <div class="meta">
            <span id="roomLine">Room: CLASS1</span>
            <span class="dot">‚Ä¢</span>
            <span id="roleLine">Role: Player/Projector</span>
            <span class="dot">‚Ä¢</span>
            <span id="turnLine">Turn: ‚Äî</span>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="chips">
          <div class="chip blue">üîµ Blue left: <b id="blueLeft">‚Äî</b></div>
          <div class="chip red">üî¥ Red left: <b id="redLeft">‚Äî</b></div>
          <div class="chip neu">‚ö™ Neutral: <b id="neutralLeft">‚Äî</b></div>
          <div class="chip">
            <span class="timerCircle" id="timerCircle">OFF</span>
            <span id="timerText">Timer OFF</span>
          </div>
        </div>

        <div class="actions">
          <button class="btn primary" id="btnNew">New Game</button>
          <button class="btn" id="btnCopyProjector">Copy Projector Link</button>
          <button class="btn" id="btnCopyBlueSpy" style="display:none;">Copy Blue Spy Link</button>
          <button class="btn" id="btnCopyRedSpy" style="display:none;">Copy Red Spy Link</button>
        </div>
      </div>
    </header>

    <section class="clueBar">
      <div class="clueCard">
        <div class="clueLabel">Clue</div>
        <div class="clueText" id="clueText">‚Äî</div>
        <div class="numBox" id="clueNum">‚Äî</div>
        <div class="guessInfo">
          <span>Guesses left</span>
          <b id="guessesLeft">‚Äî</b>
        </div>
      </div>

      <div class="smPanel" id="smPanel">
        <div class="smHeader">
          <div class="tag">Spymaster Control</div>
          <div class="teamPill" id="smTeamPill">TEAM</div>
        </div>

        <div class="smRow">
          <input id="clueInput" placeholder="CLUE (e.g., NETWORK)" maxlength="20">
          <input id="numInput" placeholder="NUMBER" type="number" min="0" max="9">
          <button class="btn primary" id="btnSendClue">Send Clue</button>
          <button class="btn" id="btnEndTurn">End Turn</button>
        </div>

        <div class="timerRow">
          <label class="toggle">
            <input type="checkbox" id="timerOn">
            Use Timer
          </label>
          <input id="secInput" placeholder="Seconds" type="number" min="10" max="600">
          <button class="btn" id="btnStartTimer">Start</button>
          <button class="btn" id="btnStopTimer">Stop</button>
        </div>

        <div style="margin-top:10px;color:rgba(234,240,255,.70);font-weight:850;font-size:12.5px;line-height:1.35;">
          Rules: Correct guesses reduce the round counter. Wrong / Neutral ends the turn instantly. Assassin = instant loss.
        </div>
      </div>
    </section>

    <main class="board" id="board"></main>
  </div>

  <!-- Password Gate -->
  <div class="gate" id="gate">
    <div class="box">
      <h2>Enter Access Password</h2>
      <p>This game is private. Only people with the link can enter.</p>
      <div class="row">
        <input id="pwInput" placeholder="Password">
        <button class="btn primary" id="pwEnter">Start</button>
      </div>
      <p style="margin-top:10px;">Tip: your link can include <b>pw=LY10</b> so this screen will be skipped.</p>
    </div>
  </div>

  <!-- End Overlay -->
  <div class="overlay" id="overlay">
    <div class="panel">
      <div class="hero" id="hero">
        <div class="titleBlock">
          <h3 id="endTitle">‚Äî</h3>
          <p class="sub" id="endSub">‚Äî</p>
          <p class="sub" id="endSummary" style="opacity:.9;margin-top:8px;"></p>
        </div>

        <div class="robotWrap" id="robotWrap"></div>
      </div>

      <div class="footer">
        <button class="btn primary" id="endNew">New Game</button>
        <div style="display:flex; gap:8px; align-items:center;">
          <span style="color:rgba(234,240,255,.65);font-weight:850;font-size:12px;">
            ESC closes (Spymaster only)
          </span>
          <button class="btn danger" id="endClose" style="display:none;">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

    // ====== CONFIG ======
    const PASSWORD = "LY10";
    const ROOM_ID = "CLASS1";

    const BLUE_KEY = "BLUE-777";
    const RED_KEY  = "RED-777";

    const firebaseConfig = {
      apiKey: "AIzaSyBaQKAER5HLq6LhPWIaIqrBRpd4qn0lUss",
      authDomain: "codenames-it-support.firebaseapp.com",
      projectId: "codenames-it-support",
      storageBucket: "codenames-it-support.firebasestorage.app",
      messagingSenderId: "328187580670",
      appId: "1:328187580670:web:b18953ccf1ad374a1dd5af",
      measurementId: "G-NVG0G4SM6D"
    };

    const WORDS = [
      "Ticket","Service Desk","VPN","Firewall","DNS",
      "DHCP","IP Address","Router","Switch","Wi-Fi",
      "Active Directory","Password","MFA","Account","Permissions",
      "Hardware","Software","Printer","Antivirus","Patch",
      "Backup","Restore","Incident","Outage","Email"
    ];

    const ICONS = {
      "Ticket":"üé´","Service Desk":"üéß","VPN":"üõ°Ô∏è","Firewall":"üî•","DNS":"üåê",
      "DHCP":"üì°","IP Address":"üß≠","Router":"üì∂","Switch":"üîÄ","Wi-Fi":"üì°",
      "Active Directory":"üë•","Password":"üîë","MFA":"‚úÖ","Account":"üßæ","Permissions":"üß∑",
      "Hardware":"üß©","Software":"üíø","Printer":"üñ®Ô∏è","Antivirus":"üß™","Patch":"ü©π",
      "Backup":"üíæ","Restore":"‚è™","Incident":"üö®","Outage":"‚õî","Email":"‚úâÔ∏è"
    };

    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }
    const otherTeam = (t)=> t==="blue" ? "red" : "blue";

    function playClick(){
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "square";
        o.frequency.value = 680;
        g.gain.value = 0.03;
        o.connect(g); g.connect(ctx.destination);
        o.start();
        setTimeout(()=>{ o.stop(); ctx.close(); }, 55);
      }catch{}
    }
    function playWin(){
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type="sine";
        o.connect(g); g.connect(ctx.destination);
        const t = ctx.currentTime;
        g.gain.setValueAtTime(0.0001,t);
        g.gain.exponentialRampToValueAtTime(0.12,t+0.02);
        const notes=[523.25,659.25,783.99,1046.5];
        notes.forEach((f,i)=>o.frequency.setValueAtTime(f,t+i*0.12));
        g.gain.exponentialRampToValueAtTime(0.0001,t+0.62);
        o.start(t); o.stop(t+0.66);
      }catch{}
    }

    // ====== URL ROLE ======
    const qs = new URLSearchParams(location.search);
    const pw = qs.get("pw") || "";
    const role = (qs.get("role") || "player").toLowerCase();
    const team = (qs.get("team") || "").toLowerCase();
    const key  = (qs.get("key") || "");

    const isSpy =
      role === "spymaster" &&
      ( (team==="blue" && key===BLUE_KEY) || (team==="red" && key===RED_KEY) );

    const spyTeam = isSpy ? team : null;

    // ====== PASSWORD GATE ======
    const gate = document.getElementById("gate");
    const pwInput = document.getElementById("pwInput");
    const pwEnter = document.getElementById("pwEnter");

    function accessOk(){
      if(pw === PASSWORD) return true;
      if(sessionStorage.getItem("cn_pw_ok")==="1") return true;
      return false;
    }

    function showGate(){
      gate.style.display = "flex";
      pwInput.value = "";
      pwInput.focus();
    }
    function hideGate(){
      gate.style.display = "none";
    }

    pwEnter.addEventListener("click", ()=>{
      const v = (pwInput.value||"").trim();
      if(v === PASSWORD){
        sessionStorage.setItem("cn_pw_ok","1");
        hideGate();
      }else{
        alert("Wrong password");
      }
    });

    if(!accessOk()){
      showGate();
    }

    // ====== UI refs ======
    document.getElementById("roomLine").textContent = "Room: " + ROOM_ID;
    document.getElementById("roleLine").textContent = isSpy ? `Role: Spymaster (${spyTeam.toUpperCase()})` : "Role: Player/Projector";

    const smPanel = document.getElementById("smPanel");
    if(isSpy) smPanel.style.display = "block";

    const btnCopyBlueSpy = document.getElementById("btnCopyBlueSpy");
    const btnCopyRedSpy  = document.getElementById("btnCopyRedSpy");
    if(isSpy){
      btnCopyBlueSpy.style.display = "inline-block";
      btnCopyRedSpy.style.display  = "inline-block";
    }

    const boardEl = document.getElementById("board");
    const clueTextEl = document.getElementById("clueText");
    const clueNumEl = document.getElementById("clueNum");
    const guessesLeftEl = document.getElementById("guessesLeft");
    const blueLeftEl = document.getElementById("blueLeft");
    const redLeftEl = document.getElementById("redLeft");
    const neutralLeftEl = document.getElementById("neutralLeft");
    const turnLineEl = document.getElementById("turnLine");

    const timerTextEl = document.getElementById("timerText");
    const timerCircle = document.getElementById("timerCircle");
    const nearBlue = document.getElementById("nearBlue");
    const nearRed  = document.getElementById("nearRed");

    // spymaster controls
    const clueInput = document.getElementById("clueInput");
    const numInput  = document.getElementById("numInput");
    const btnSendClue = document.getElementById("btnSendClue");
    const btnEndTurn  = document.getElementById("btnEndTurn");

    const timerOn = document.getElementById("timerOn");
    const secInput = document.getElementById("secInput");
    const btnStartTimer = document.getElementById("btnStartTimer");
    const btnStopTimer  = document.getElementById("btnStopTimer");

    const btnNew = document.getElementById("btnNew");
    const btnCopyProjector = document.getElementById("btnCopyProjector");

    // overlay
    const overlay = document.getElementById("overlay");
    const hero = document.getElementById("hero");
    const endTitle = document.getElementById("endTitle");
    const endSub = document.getElementById("endSub");
    const endSummary = document.getElementById("endSummary");
    const robotWrap = document.getElementById("robotWrap");
    const endNew = document.getElementById("endNew");
    const endClose = document.getElementById("endClose");

    if(isSpy) endClose.style.display = "inline-block";

    // robots (simple SVG, no external images)
    function robotSVG(color){
      const c = color==="blue" ? "#4EA2FF" : "#FF5A76";
      const eye = color==="blue" ? "#BFE3FF" : "#FFD0D9";
      const mood = color==="blue" ? "Calm mode" : "Power mode";
      return `
        <svg viewBox="0 0 420 420" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="g1" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0" stop-color="${c}" stop-opacity="0.95"/>
              <stop offset="1" stop-color="#0B1020" stop-opacity="0.85"/>
            </linearGradient>
            <filter id="sh" x="-40%" y="-40%" width="180%" height="180%">
              <feDropShadow dx="0" dy="18" stdDeviation="14" flood-color="#000" flood-opacity=".55"/>
            </filter>
          </defs>

          <g filter="url(#sh)">
            <rect x="120" y="70" rx="26" ry="26" width="180" height="170" fill="url(#g1)" stroke="rgba(255,255,255,.22)" stroke-width="2"/>
            <rect x="135" y="90" rx="22" ry="22" width="150" height="90" fill="rgba(0,0,0,.25)" stroke="rgba(255,255,255,.18)" stroke-width="2"/>
            <circle cx="185" cy="135" r="14" fill="${eye}" opacity="0.95"/>
            <circle cx="235" cy="135" r="14" fill="${eye}" opacity="0.95"/>
            <rect x="180" y="165" rx="10" ry="10" width="60" height="12" fill="rgba(255,255,255,.75)" opacity="0.55"/>

            <rect x="150" y="240" rx="22" ry="22" width="120" height="110" fill="rgba(255,255,255,.06)" stroke="rgba(255,255,255,.18)" stroke-width="2"/>
            <rect x="165" y="262" rx="12" ry="12" width="90" height="16" fill="rgba(255,255,255,.20)"/>
            <rect x="165" y="290" rx="12" ry="12" width="90" height="16" fill="rgba(255,255,255,.16)"/>
            <rect x="165" y="318" rx="12" ry="12" width="90" height="16" fill="rgba(255,255,255,.12)"/>

            <text x="210" y="388" text-anchor="middle" fill="rgba(234,240,255,.70)" font-family="ui-sans-serif,system-ui" font-weight="900" font-size="16">${mood}</text>
          </g>

          <circle cx="210" cy="55" r="10" fill="${c}" opacity="0.9"/>
          <rect x="206" y="30" width="8" height="22" rx="4" fill="rgba(255,255,255,.35)"/>
        </svg>
      `;
    }

    function baseUrl(){
      return location.origin + location.pathname;
    }

    function linkProjector(){
      return `${baseUrl()}?pw=${encodeURIComponent(PASSWORD)}`;
    }
    function linkSpy(t){
      const k = (t==="blue") ? BLUE_KEY : RED_KEY;
      return `${baseUrl()}?pw=${encodeURIComponent(PASSWORD)}&role=spymaster&team=${t}&key=${encodeURIComponent(k)}`;
    }

    btnCopyProjector.addEventListener("click", async ()=>{
      await navigator.clipboard.writeText(linkProjector());
      alert("Projector link copied ‚úÖ");
    });
    btnCopyBlueSpy.addEventListener("click", async ()=>{
      await navigator.clipboard.writeText(linkSpy("blue"));
      alert("Blue spymaster link copied ‚úÖ");
    });
    btnCopyRedSpy.addEventListener("click", async ()=>{
      await navigator.clipboard.writeText(linkSpy("red"));
      alert("Red spymaster link copied ‚úÖ");
    });

    // ====== FIREBASE ======
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const roomRef = doc(db, "rooms", ROOM_ID);

    function makeNewState(){
      const startingTeam = Math.random() < 0.5 ? "blue" : "red";
      const blueCount = startingTeam==="blue" ? 9 : 8;
      const redCount  = startingTeam==="red"  ? 9 : 8;
      const neutralCount = 25 - blueCount - redCount - 1;

      const colors = shuffle([
        ...Array(blueCount).fill("blue"),
        ...Array(redCount).fill("red"),
        ...Array(neutralCount).fill("neutral"),
        "assassin"
      ]);

      const words = shuffle(WORDS);
      const mapping = {};
      for(let i=0;i<25;i++){
        mapping[words[i]] = { team: colors[i], revealed:false };
      }

      return {
        roomId: ROOM_ID,
        words,
        mapping,
        startingTeam,
        activeTeam: startingTeam,
        phase: "clue",          // "clue" or "guess"
        clueText: "‚Äî",
        clueNumber: "‚Äî",
        guessesLeft: 0,

        timerEnabled: false,
        timerSeconds: 60,
        timerRunning: false,
        timerEndsAt: null,

        winner: null,           // "blue" | "red" | null
        loser: null,            // "blue" | "red" | null (assassin)
        updatedAt: serverTimestamp()
      };
    }

    async function ensureRoom(){
      const snap = await getDoc(roomRef);
      if(!snap.exists()){
        await setDoc(roomRef, makeNewState());
      }
    }

    btnNew.addEventListener("click", async ()=>{
      await setDoc(roomRef, makeNewState());
    });
    endNew.addEventListener("click", async ()=>{
      await setDoc(roomRef, makeNewState());
      hideOverlay();
    });

    function counts(mapping){
      let blue=0, red=0, neutral=0;
      for(const w in mapping){
        const c = mapping[w];
        if(!c.revealed && c.team==="blue") blue++;
        if(!c.revealed && c.team==="red") red++;
        if(!c.revealed && c.team==="neutral") neutral++;
      }
      return {blue, red, neutral};
    }

    async function endTurn(cur){
      const next = otherTeam(cur.activeTeam);
      await updateDoc(roomRef, {
        activeTeam: next,
        phase: "clue",
        clueText: "‚Äî",
        clueNumber: "‚Äî",
        guessesLeft: 0,
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    }

    async function reveal(word){
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner || cur.loser) return;

      const mapping = cur.mapping || {};
      const cell = mapping[word];
      if(!cell || cell.revealed) return;

      cell.revealed = true;

      // assassin = instant loss for active team
      if(cell.team === "assassin"){
        await updateDoc(roomRef, {
          mapping,
          loser: cur.activeTeam,
          winner: otherTeam(cur.activeTeam),
          timerRunning: false,
          timerEndsAt: null,
          updatedAt: serverTimestamp()
        });
        return;
      }

      // check win after reveal
      const after = counts(mapping);
      if(after.blue === 0){
        await updateDoc(roomRef, { mapping, winner:"blue", updatedAt: serverTimestamp() });
        return;
      }
      if(after.red === 0){
        await updateDoc(roomRef, { mapping, winner:"red", updatedAt: serverTimestamp() });
        return;
      }

      // if in guess phase: apply rules
      if(cur.phase === "guess"){
        if(cell.team === cur.activeTeam){
          const newLeft = Math.max(0, (cur.guessesLeft||0) - 1);
          await updateDoc(roomRef, { mapping, guessesLeft: newLeft, updatedAt: serverTimestamp() });

          // if guesses finished -> auto end turn
          if(newLeft <= 0){
            // re-read is optional; using cur is fine
            await endTurn({ ...cur, guessesLeft: newLeft, mapping });
          }
        } else {
          // wrong team OR neutral -> end turn immediately
          await updateDoc(roomRef, { mapping, updatedAt: serverTimestamp() });
          await endTurn(cur);
        }
      } else {
        // clue phase: allow reveal (if someone clicked early) but do not change guesses
        await updateDoc(roomRef, { mapping, updatedAt: serverTimestamp() });
      }
    }

    // ====== Rendering without heavy re-build ======
    let cardsBuilt = false;
    const cardEls = new Map(); // word -> element
    let lastRevealed = {};     // word -> bool
    let lastState = null;

    function setNearVictory(teamOn){
      nearBlue.classList.toggle("on", teamOn==="blue");
      nearRed.classList.toggle("on", teamOn==="red");
    }

    function setTimerUI(state){
      if(!state.timerEnabled){
        timerTextEl.textContent = "Timer OFF";
        timerCircle.textContent = "OFF";
        timerCircle.style.background = "conic-gradient(rgba(255,255,255,.15) 0deg, rgba(255,255,255,.10) 0deg)";
        return;
      }
      if(!state.timerRunning || !state.timerEndsAt){
        timerTextEl.textContent = "Timer READY";
        timerCircle.textContent = "‚Äî";
        timerCircle.style.background = "conic-gradient(rgba(78,162,255,.45) 360deg, rgba(255,255,255,.10) 0deg)";
        return;
      }
      const ms = state.timerEndsAt - Date.now();
      const sec = Math.max(0, Math.ceil(ms/1000));
      timerTextEl.textContent = "Time: " + sec + "s";
      timerCircle.textContent = String(sec);

      const total = Math.max(10, Math.min(600, Number(state.timerSeconds||60)));
      const frac = Math.max(0, Math.min(1, sec / total));
      const deg = Math.round(frac * 360);

      // green -> yellow -> red
      let col = "rgba(78,162,255,.65)";
      if(frac <= 0.35) col = "rgba(255,90,118,.70)";
      else if(frac <= 0.65) col = "rgba(255,210,90,.65)";

      timerCircle.style.background = `conic-gradient(${col} ${deg}deg, rgba(255,255,255,.10) 0deg)`;
    }

    let timerTick = null;
    function startTimerTicker(){
      if(timerTick) clearInterval(timerTick);
      timerTick = setInterval(()=>{
        if(lastState) setTimerUI(lastState);
        // if timer ends: let spymaster auto-end turn (only once)
        if(lastState && lastState.timerEnabled && lastState.timerRunning && lastState.timerEndsAt){
          const sec = Math.max(0, Math.ceil((lastState.timerEndsAt - Date.now())/1000));
          if(sec <= 0){
            // stop locally
            clearInterval(timerTick); timerTick=null;
            // end turn (anyone can write, rules allow; but usually spymaster is controlling)
            getDoc(roomRef).then(s=>{
              if(!s.exists()) return;
              const cur = s.data();
              if(cur.winner || cur.loser) return;
              if(cur.phase === "guess" && cur.timerRunning){
                endTurn(cur);
              }
            });
          }
        }
      }, 1000); // 1s to avoid lag / flashing
    }

    function buildBoardOnce(state){
      boardEl.innerHTML = "";
      cardEls.clear();
      lastRevealed = {};

      for(const w of state.words){
        const cell = state.mapping[w];
        const btn = document.createElement("div");
        btn.className = "card";
        btn.tabIndex = 0;

        const icon = document.createElement("div");
        icon.className = "icon";
        icon.textContent = ICONS[w] || "‚öôÔ∏è";

        const word = document.createElement("div");
        word.className = "word";
        word.textContent = w;

        btn.appendChild(icon);
        btn.appendChild(word);

        btn.addEventListener("click", ()=>{
          if(!accessOk()) return;
          if(lastState?.winner || lastState?.loser) return;
          playClick();
          reveal(w);
        });

        boardEl.appendChild(btn);
        cardEls.set(w, btn);
        lastRevealed[w] = false;

        // initial spymaster hint border
        if(isSpy && cell){
          btn.classList.add("hint");
          btn.classList.add(cell.team); // blue/red/neutral/assassin
        }
      }
      cardsBuilt = true;
    }

    function updateCards(state){
      for(const w of state.words){
        const cell = state.mapping[w];
        const el = cardEls.get(w);
        if(!cell || !el) continue;

        // spymaster hint border
        if(isSpy){
          el.classList.add("hint");
          el.classList.toggle("blue", cell.team==="blue");
          el.classList.toggle("red", cell.team==="red");
          el.classList.toggle("neutral", cell.team==="neutral");
          el.classList.toggle("assassin", cell.team==="assassin");
        }else{
          el.classList.remove("hint","blue","red","neutral","assassin");
        }

        // revealed state (update only if changed)
        const was = !!lastRevealed[w];
        const now = !!cell.revealed;
        if(was !== now){
          el.classList.toggle("revealed", now);
          el.classList.toggle("blue", now && cell.team==="blue");
          el.classList.toggle("red", now && cell.team==="red");
          el.classList.toggle("neutral", now && cell.team==="neutral");
          el.classList.toggle("assassin", now && cell.team==="assassin");
          lastRevealed[w] = now;
        } else {
          // keep classes correct (just in case)
          if(now){
            el.classList.toggle("blue", cell.team==="blue");
            el.classList.toggle("red", cell.team==="red");
            el.classList.toggle("neutral", cell.team==="neutral");
            el.classList.toggle("assassin", cell.team==="assassin");
            el.classList.add("revealed");
          }else{
            el.classList.remove("revealed");
          }
        }
      }
    }

    function showOverlay(type, state){
      overlay.style.display = "flex";

      if(type==="winBlue"){
        hero.className = "hero blue";
        endTitle.textContent = "BLUE TEAM WINS";
        endSub.textContent = "All blue keywords found.";
        robotWrap.innerHTML = robotSVG("blue");
      } else if(type==="winRed"){
        hero.className = "hero red";
        endTitle.textContent = "RED TEAM WINS";
        endSub.textContent = "All red keywords found.";
        robotWrap.innerHTML = robotSVG("red");
      } else if(type==="loseBlue"){
        hero.className = "hero black";
        endTitle.textContent = "BLUE TEAM LOST";
        endSub.textContent = "Assassin card was revealed.";
        robotWrap.innerHTML = robotSVG("red");
      } else if(type==="loseRed"){
        hero.className = "hero black";
        endTitle.textContent = "RED TEAM LOST";
        endSub.textContent = "Assassin card was revealed.";
        robotWrap.innerHTML = robotSVG("blue");
      }

      const c = counts(state.mapping);
      endSummary.textContent = `Remaining ‚Äî Blue: ${c.blue} | Red: ${c.red} | Neutral: ${c.neutral}`;

      if(isSpy){
        endClose.style.display = "inline-block";
      }else{
        endClose.style.display = "none";
      }
    }

    function hideOverlay(){
      overlay.style.display = "none";
    }

    endClose.addEventListener("click", ()=>{
      if(!isSpy) return;
      hideOverlay();
    });

    window.addEventListener("keydown", (e)=>{
      if(e.key === "Escape" && overlay.style.display === "flex"){
        if(isSpy) hideOverlay();
      }
    });

    function render(state){
      lastState = state;

      // header and clue info
      turnLineEl.textContent = `Turn: ${String(state.activeTeam||"‚Äî").toUpperCase()} ‚Ä¢ ${String(state.phase||"‚Äî").toUpperCase()}`;
      clueTextEl.textContent = state.clueText || "‚Äî";
      clueNumEl.textContent  = state.clueNumber || "‚Äî";
      guessesLeftEl.textContent = String(state.guessesLeft ?? "‚Äî");

      const c = counts(state.mapping || {});
      blueLeftEl.textContent = c.blue;
      redLeftEl.textContent = c.red;
      neutralLeftEl.textContent = c.neutral;

      // near victory mode (only when 1 left)
      if(c.blue === 1) setNearVictory("blue");
      else if(c.red === 1) setNearVictory("red");
      else setNearVictory(null);

      // timer UI
      setTimerUI(state);
      startTimerTicker();

      // spymaster enable/disable
      if(isSpy){
        document.getElementById("smTeamPill").textContent = `YOU: ${spyTeam.toUpperCase()} ‚Ä¢ ACTIVE: ${state.activeTeam.toUpperCase()}`;
        const myTurn = (spyTeam === state.activeTeam);

        btnSendClue.disabled = !(myTurn && state.phase==="clue" && !state.winner && !state.loser);
        btnEndTurn.disabled  = !(myTurn && state.phase==="guess" && !state.winner && !state.loser);

        timerOn.checked = !!state.timerEnabled;
        secInput.value = state.timerSeconds ?? 60;

        btnStartTimer.disabled = !(myTurn && state.phase==="guess" && state.timerEnabled && !state.timerRunning && !state.winner && !state.loser);
        btnStopTimer.disabled  = !(myTurn && state.timerRunning && !state.winner && !state.loser);
      }

      // build board once
      if(!cardsBuilt){
        buildBoardOnce(state);
      }
      updateCards(state);

      // overlay logic
      if(state.winner){
        if(state.winner === "blue"){
          if(overlay.style.display!=="flex"){ playWin(); }
          showOverlay("winBlue", state);
        }else if(state.winner === "red"){
          if(overlay.style.display!=="flex"){ playWin(); }
          showOverlay("winRed", state);
        }
      } else if(state.loser){
        // loser is the team who clicked assassin
        if(state.loser === "blue"){
          showOverlay("loseBlue", state);
        } else if(state.loser === "red"){
          showOverlay("loseRed", state);
        }
      } else {
        // keep closed if not finished
        if(overlay.style.display==="flex") hideOverlay();
      }
    }

    // ====== Spymaster actions ======
    btnSendClue.addEventListener("click", async ()=>{
      if(!isSpy) return;
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner || cur.loser) return;
      if(cur.phase !== "clue") return;
      if(cur.activeTeam !== spyTeam) return;

      const clue = (clueInput.value||"").trim().toUpperCase();
      const n = Number((numInput.value||"").trim());
      if(!clue || !Number.isFinite(n) || n<0 || n>9){
        alert("Enter a clue + number (0-9)");
        return;
      }

      await updateDoc(roomRef,{
        clueText: clue,
        clueNumber: String(n),
        guessesLeft: n,
        phase: "guess",
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });

      clueInput.value = "";
      numInput.value = "";
    });

    btnEndTurn.addEventListener("click", async ()=>{
      if(!isSpy) return;
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner || cur.loser) return;
      if(cur.phase !== "guess") return;
      if(cur.activeTeam !== spyTeam) return;
      await endTurn(cur);
    });

    timerOn.addEventListener("change", async ()=>{
      if(!isSpy) return;
      const enabled = !!timerOn.checked;
      const seconds = Math.max(10, Math.min(600, Number(secInput.value||60)));
      await updateDoc(roomRef,{
        timerEnabled: enabled,
        timerSeconds: Number.isFinite(seconds) ? seconds : 60,
        updatedAt: serverTimestamp()
      });
    });

    btnStartTimer.addEventListener("click", async ()=>{
      if(!isSpy) return;
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.winner || cur.loser) return;
      if(cur.phase !== "guess") return;
      if(cur.activeTeam !== spyTeam) return;
      if(!cur.timerEnabled) return;

      const seconds = Math.max(10, Math.min(600, Number(cur.timerSeconds||60)));
      const ends = Date.now() + seconds*1000;

      await updateDoc(roomRef,{
        timerRunning: true,
        timerEndsAt: ends,
        updatedAt: serverTimestamp()
      });
    });

    btnStopTimer.addEventListener("click", async ()=>{
      if(!isSpy) return;
      const snap = await getDoc(roomRef);
      if(!snap.exists()) return;
      const cur = snap.data();
      if(cur.activeTeam !== spyTeam) return;

      await updateDoc(roomRef,{
        timerRunning: false,
        timerEndsAt: null,
        updatedAt: serverTimestamp()
      });
    });

    // ====== START ======
    await ensureRoom();
    onSnapshot(roomRef, (snap)=>{
      if(!snap.exists()) return;
      render(snap.data());
    });
  </script>
</body>
</html>
